# -*- coding: utf-8 -*-
"""
LinkPass â€” Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹
ÐÐ²Ñ‚Ð¾Ñ€: Ð¡Ð°Ð²Ð¸Ð½ Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹ ÐžÐ»ÐµÐ³Ð¾Ð²Ð¸Ñ‡
Ð¡Ð°Ð¹Ñ‚: www.linkpass.ru
"""
import sys, os, json, shutil, base64, hashlib, secrets, zipfile, sqlite3, csv, math, io, traceback, subprocess, ctypes, tempfile, signal
APP_TITLE = "LinkPass â€” Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹"
CURRENT_VERSION = 1
SHARE_TEMP_TTL_SEC = 60
from datetime import datetime, timedelta
import importlib
import re
from urllib.parse import quote
MAX_CARDS = 300
CARD_FIELDS_LIMIT = 12
SEARCH_DEBOUNCE_MS = 250
TREE_RENDER_DELAY_MS = 60
DEFAULT_EXPAND_DEPTH = -1
ARGON2_TIME_COST = 4
ARGON2_MEMORY_COST = 128 * 1024
ARGON2_PARALLELISM = 2
SALT_LEN = 32
KDF_DEFAULTS = {
    "t": ARGON2_TIME_COST,
    "m": ARGON2_MEMORY_COST,
    "p": ARGON2_PARALLELISM,
}
def _mix_master_with_pepper(master: str) -> str:
    try:
        pep_b64 = os.environ.get("LINKPASS_PEPPER_B64", "").strip()
        if pep_b64:
            pep = base64.b64decode(pep_b64)
            h = hashlib.sha256(pep).hexdigest()
            return f"{master}\u2063{h}"
    except Exception:
        pass
    return master
REQUIRED_PKGS = [
    ("PySide6",       "PySide6",      "GUI"),
    ("cryptography",  "cryptography", "Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ (Fernet)"),
    ("pandas",        "pandas",       "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚/Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ Ñ‚Ð°Ð±Ð»Ð¸Ñ†"),
    ("openpyxl",      "openpyxl",     ".xlsx Ð´Ð»Ñ pandas"),
    ("argon2-cffi",   "argon2",       "Ð¡Ð¾Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ð¹ KDF Argon2id"),
]
OPTIONAL_PKGS = [
    ("pillow",  "PIL",     "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ-Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ (Ð¾Ð¿Ñ†.)"),
    ("pyotp",   "pyotp",   "TOTP (Ð¾Ð¿Ñ†.)"),
    ("qrcode",  "qrcode",  "QR-ÐºÐ¾Ð´Ñ‹ (Ð¾Ð¿Ñ†.)"),
    ("pysqlite3-binary", "pysqlite3", "FTS5 Ñ‚Ð°Ð¼, Ð³Ð´Ðµ SQLite ÑƒÑ€ÐµÐ·Ð°Ð½ (Ð¾Ð¿Ñ†.)"),
]
if sys.version_info >= (3, 13):
    OPTIONAL_PKGS = [t for t in OPTIONAL_PKGS if t[0] != "pysqlite3-binary"]
def ensure_dependencies():
    missing = []
    for pip_name, import_name, _ in REQUIRED_PKGS:
        try:
            importlib.import_module(import_name)
        except Exception:
            missing.append(pip_name)
    if missing:
        print("\n[LinkPass] ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°ÐºÐµÑ‚Ñ‹:\n  " + ", ".join(missing))
        print("Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ:\n  pip install " + " ".join(missing))
        sys.exit(1)
    opt_missing = []
    for pip_name, import_name, _ in OPTIONAL_PKGS:
        if pip_name == "pysqlite3-binary" and sys.version_info >= (3, 13):
            continue
        try:
            importlib.import_module(import_name)
        except Exception:
            opt_missing.append(pip_name)
    if opt_missing:
        print("[LinkPass] ÐžÐ¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°ÐºÐµÑ‚Ñ‹ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹: " + ", ".join(opt_missing))
        print("  ÐŸÐ¾ Ð¶ÐµÐ»Ð°Ð½Ð¸ÑŽ: pip install " + " ".join(opt_missing))
ensure_dependencies()
import pandas as pd
from PySide6 import QtCore
from PySide6.QtCore import Qt, QTimer, QObject, QEvent, Signal, QCoreApplication, QUrl, QLocale, QUrlQuery, QSize
from PySide6.QtGui import QAction, QIcon, QDrag, QDesktopServices, QColor, QPixmap, QCursor, QImageReader, QPainter, QPen, QFont
from PySide6.QtWidgets import (
    QApplication, QWidget, QTreeWidget, QTreeWidgetItem, QHBoxLayout, QVBoxLayout,
    QPushButton, QMenu, QInputDialog, QMessageBox, QLabel, QLineEdit, QScrollArea,
    QFileDialog, QMainWindow, QFrame, QGridLayout, QSplitter, QDialog, QComboBox,
    QTableWidget, QTableWidgetItem, QAbstractItemView, QListWidget, QTextEdit,
    QSystemTrayIcon, QTabWidget, QDateTimeEdit, QColorDialog, QSpinBox, QDialogButtonBox,
    QCheckBox, QPlainTextEdit, QStackedWidget, QProgressDialog, QLayout,
    QToolButton, QProgressBar, QWidgetItem, QSizePolicy, QHeaderView
)
def tr(s: str, *args, **kwargs):
    try:   
        return s.format(*args, **kwargs)
    except Exception:
        return s
def translate_widget_tree(*_args, **_kwargs):
    return
from typing import Optional, Callable, Any, List, Tuple
try:
    import pyotp
    HAS_TOTP = True
except Exception:
    HAS_TOTP = False
try:
    from argon2.low_level import hash_secret as _argon_hash_secret, Type as _Argon2Type
except Exception:
    _argon_hash_secret = None
    _Argon2Type = None
HAS_ARGON2: bool = _argon_hash_secret is not None and _Argon2Type is not None
from cryptography.fernet import Fernet, InvalidToken
class WrongMasterPasswordError(Exception):
    pass
def brand_icon(name: str) -> QIcon:
    try:
        p = resource_path(f"icons/{name}.png")
        return QIcon(p) if os.path.exists(p) else QIcon()
    except Exception:
        return QIcon()
from typing import Optional
def resource_path(relative_path: str) -> str:
    base: Optional[str] = getattr(sys, "_MEIPASS", None)
    if isinstance(base, str) and base:
        return os.path.join(base, relative_path)
    return os.path.join(os.path.abspath("."), relative_path)
def get_data_dir():
    if sys.platform.startswith('win'):
        return os.path.join(os.environ.get('APPDATA', os.path.expanduser('~')), 'LinkPass')
    elif sys.platform.startswith('darwin'):
        return os.path.expanduser('~/Library/Application Support/LinkPass')
    else:
        return os.path.expanduser('~/.local/share/LinkPass')
DATA_DIR  = get_data_dir()
os.makedirs(DATA_DIR, exist_ok=True)
ICON_PATH = resource_path('favicon.ico')
TREE_FILE   = os.path.join(DATA_DIR, "tree.json")
BLOCKS_FILE = os.path.join(DATA_DIR, "blocks.json")
TRASH_FILE  = os.path.join(DATA_DIR, "trash.json")
META_FILE   = os.path.join(DATA_DIR, "meta.json")
MASTER_FILE = os.path.join(DATA_DIR, "auth.json")
SNAP_DIR    = os.path.join(DATA_DIR, "snapshots")
INDEX_DB    = os.path.join(DATA_DIR, "index.db")
ATTACH_DIR  = os.path.join(DATA_DIR, "attachments")
for d in (SNAP_DIR, ATTACH_DIR):
    os.makedirs(d, exist_ok=True)
PROGRAM_INFO = (
    "LinkPass â€” Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹\n"
    "Ð’ÐµÑ€ÑÐ¸Ñ: 1.0.0\n"
    "\n"
    "Copyright (c) 2025 Ð¡Ð°Ð²Ð¸Ð½ Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹ ÐžÐ»ÐµÐ³Ð¾Ð²Ð¸Ñ‡\n"
    "Ð¡Ð°Ð¹Ñ‚ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹: https://linkpass.ru\n"
    "Ð›Ð¸Ñ†ÐµÐ½Ð·Ð¸Ñ: MIT License\n"
     "\n"
    "ðŸ’– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚: https://yoomoney.ru/to/410011663886937\n"
    
)
MANUAL_TEXT = """\
LinkPass â€” Ð ÑƒÐºÐ¾Ð²Ð¾Ð´ÑÑ‚Ð²Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ

ÐžÐ³Ð»Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ
1. Ð§Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ LinkPass Ð¸ ÐºÐ°Ðº Ð¾Ð½ ÑƒÑÑ‚Ñ€Ð¾ÐµÐ½
2. ÐŸÐµÑ€Ð²Ñ‹Ð¹ Ð·Ð°Ð¿ÑƒÑÐº Ð¸ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ
3. Ð’Ñ…Ð¾Ð´ Ð² Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð¸ Ð°Ð²Ñ‚Ð¾Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ ÑÐµÐ°Ð½ÑÐ°
4. ÐžÐ±Ð·Ð¾Ñ€ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°
5. Ð Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð¸ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ (Ð´ÐµÑ€ÐµÐ²Ð¾ ÑÐ»ÐµÐ²Ð°)
6. Ð‘Ð»Ð¾ÐºÐ¸ (ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ ÑÐ¿Ñ€Ð°Ð²Ð°)
7. ÐŸÐ¾Ð»Ñ: Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ, Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ, ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ, ÑÑÑ‹Ð»ÐºÐ¸
8. Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ (Ñ„Ð°Ð¹Ð»Ñ‹): Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ, Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€, Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ°, ÑˆÐ°Ñ€Ð¸Ð½Ð³
9. Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸ Ð¿Ð¾ Ð±Ð»Ð¾ÐºÑƒ
10. ÐŸÐ¾Ð¸ÑÐº Ð¸ Â«Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸Â»
11. ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ, ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ
12. Ð—Ð°Ñ‰Ð¸Ñ‚Ð° Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð² Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼, Ñ€Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ñ†ÐµÐ¿Ð¾Ñ‡ÐºÐ¸
13. Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… (XLSX/CSV/JSON/TXT)
14. Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…: Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹ Ð¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ (LPX1)
15. Ð‘ÑÐºÐ°Ð¿ Ð¸ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ (LPX1/LPBK/LPEX/ZIP)
16. Ð¡Ð¼ÐµÐ½Ð° Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ
17. ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ KDF (Argon2id): Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð¸ Ð¼Ð¸Ð³Ñ€Ð°Ñ†Ð¸Ñ
18. ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸: Telegram / WhatsApp / Email
19. Ð“Ð¾Ñ€ÑÑ‡Ð¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑˆÐ¸
20. ÐŸÐ°Ð¿ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸ Ð¿ÐµÑ€ÐµÐ½Ð¾Ñ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¾Ð¹ ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€
21. Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ ÑƒÑ‚Ñ€Ð°Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ â€” Ñ‡Ñ‚Ð¾ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ
22. Ð¡Ð¾Ð²ÐµÑ‚Ñ‹ Ð¿Ð¾ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸
ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚ LinkPass

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1) Ð§Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ LinkPass Ð¸ ÐºÐ°Ðº Ð¾Ð½ ÑƒÑÑ‚Ñ€Ð¾ÐµÐ½
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LinkPass â€” Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…/Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹. Ð’ÑÐµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÐµÐ¹ Ð¸ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ ÑˆÐ¸Ñ„Ñ€ÑƒÑŽÑ‚ÑÑ ÐºÐ»ÑŽÑ‡Ð¾Ð¼,
ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð·Ð°Ñ‰Ð¸Ñ‰Ñ‘Ð½ Ð²Ð°ÑˆÐ¸Ð¼ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼. Ð”ÐµÑ€ÐµÐ²Ð¾ ÑÐ»ÐµÐ²Ð° â€” ÑÑ‚Ð¾ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð². Ð¡Ð¿Ñ€Ð°Ð²Ð° â€” Â«ÐºÐ°Ð½Ð±Ð°Ð½Â»
Ð¸Ð· ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐµÐº (Ð±Ð»Ð¾ÐºÐ¾Ð²). Ð’Ð½ÑƒÑ‚Ñ€Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð±Ð»Ð¾ÐºÐ° â€” Ð¿Ð¾Ð»Ñ (Ð¿Ð°Ñ€Ñ‹ Â«ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ â†’ Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸ÐµÂ»), Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸ Ð¸ Ð²ÐºÐ»Ð°Ð´ÐºÐ°
Â«Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÂ».

Ð”Ð°Ð½Ð½Ñ‹Ðµ Ñ…Ñ€Ð°Ð½ÑÑ‚ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾ Ð² Â«Ð¿Ð°Ð¿ÐºÐµ Ð´Ð°Ð½Ð½Ñ‹Ñ…Â» (ÑÐ¼. Ñ€Ð°Ð·Ð´ÐµÐ» 20), Ð¸/Ð¸Ð»Ð¸ Ð² Ð²Ð°ÑˆÐ¸Ñ… ÑÐºÑÐ¿Ð¾Ñ€Ñ‚/Ð±ÑÐºÐ°Ð¿â€‘Ñ„Ð°Ð¹Ð»Ð°Ñ…,
ÐµÑÐ»Ð¸ Ð²Ñ‹ Ð¸Ñ… ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚Ðµ.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2) ÐŸÐµÑ€Ð²Ñ‹Ð¹ Ð·Ð°Ð¿ÑƒÑÐº Ð¸ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ÐŸÑ€Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¼ Ð·Ð°Ð¿ÑƒÑÐºÐµ Ð¿Ð¾ÑÐ²Ð¸Ñ‚ÑÑ Ð´Ð¸Ð°Ð»Ð¾Ð³ Â«ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒÂ». Ð—Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð½Ð°Ð´Ñ‘Ð¶Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ (Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð¾Ð²Ð°Ð½Ð¾ â‰¥ 10
  ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð², Ñ Ñ†Ð¸Ñ„Ñ€Ð°Ð¼Ð¸ Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°Ð¼Ð¸). Ð˜Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€ Ð¿Ð¾Ð´ÑÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ ÑÐ¸Ð»Ñƒ Ð¿Ð°Ñ€Ð¾Ð»Ñ.
â€¢ Ð­Ñ‚Ð¾Ñ‚ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð±ÑƒÐ´ÐµÑ‚ Ð½ÑƒÐ¶ÐµÐ½ Ð¿Ñ€Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ð¼ Ð²Ñ…Ð¾Ð´Ðµ Ð¸ Ð¿Ñ€Ð¸ Â«Ñ‡ÑƒÐ²ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ…Â» Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸ÑÑ… (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, ÑÐ¼ÐµÐ½Ð° KDF).
â€¢ ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð½ÐµÐ»ÑŒÐ·Ñ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ð¸Ñ‡ÐµÑÐºÐ¸ (ÑÐ¼. Ñ€Ð°Ð·Ð´ÐµÐ» 21). ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ ÑÐ´ÐµÐ»Ð°Ð¹Ñ‚Ðµ Ð±ÑÐºÐ°Ð¿.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3) Ð’Ñ…Ð¾Ð´ Ð² Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð¸ Ð°Ð²Ñ‚Ð¾Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ ÑÐµÐ°Ð½ÑÐ°
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ÐŸÑ€Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ð¼ ÑÑ‚Ð°Ñ€Ñ‚Ðµ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.
â€¢ Ð¡ÐµÐ°Ð½Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ: Ð·Ð½Ð°Ñ‡Ð¾Ðº Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ð¾Ð¼ Ñ‚Ñ€ÐµÐµ â†’ Â«Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒÂ».
â€¢ ÐÐ²Ñ‚Ð¾Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð¿Ð¾ Ð½ÐµÐ°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð° (ÐµÑÐ»Ð¸ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð° Ð² ÑÐ±Ð¾Ñ€ÐºÐµ): Ð¿Ñ€Ð¸ ÑÑ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ð¸ ÑÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ
  Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸ Ð¾Ñ‡Ð¸Ñ‰Ð°ÐµÑ‚ÑÑ Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°. Ð”Ð»Ñ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð¸Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ€Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ (ÑÐ¼. 12).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4) ÐžÐ±Ð·Ð¾Ñ€ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð’ÐµÑ€Ñ…Ð½ÑÑ ÑÑ‚Ñ€Ð¾ÐºÐ° â€” Ð¿Ð¾Ð¸ÑÐº Ð¸ ÐºÐ½Ð¾Ð¿ÐºÐ¸:
  â€¢ ÐŸÐ¾Ð»Ðµ Â«ÐŸÐ¾Ð¸ÑÐºâ€¦Â» Ð¸ ÑÐµÐ»ÐµÐºÑ‚Ð¾Ñ€ Â«Ð‘Ð»Ð¾ÐºÐ¸/ÐŸÐ¾Ð»ÑÂ».
  â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ° Â«âœ–Â» â€” Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ñ€Ð¾Ñ.
  â€¢ Â«Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸Â», Â«Ð¨Ð°Ð±Ð»Ð¾Ð½Ñ‹Â», Â«ÐŸÑ€ÐµÑÐµÑ‚Ñ‹Â».
  â€¢ Â«ðŸ“ŽÂ» â€” Ñ„Ð¸Ð»ÑŒÑ‚Ñ€ Â«Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð±Ð»Ð¾ÐºÐ¸ Ñ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÐ¼Ð¸Â».
  â€¢ Â«+ Ð‘Ð»Ð¾ÐºÂ» â€” ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð±Ð»Ð¾Ðº.
  â€¢ Â«ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹ÐµÂ» â€” Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ/ÑÐºÑ€Ñ‹Ñ‚ÑŒ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ°Ñ….

Ð›ÐµÐ²Ð°Ñ Ð¿Ð°Ð½ÐµÐ»ÑŒ â€” Ð´ÐµÑ€ÐµÐ²Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð²:
  â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ¸ Â«+ Ð Ð°Ð·Ð´ÐµÐ»Â», Â«+ ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Â», Â«Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒÂ».
  â€¢ ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð½Ð¾Ðµ Ð¼ÐµÐ½ÑŽ (ÐŸÐšÐœ) Ð¿Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ: Ð¿ÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ, Ñ†Ð²ÐµÑ‚, ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ°/ÑÐ½ÑÑ‚Ð¸Ðµ Ð¿Ð°Ñ€Ð¾Ð»Ñ, ÑÐºÑÐ¿Ð¾Ñ€Ñ‚ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°,
    Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ, Ð¸ÐºÐ¾Ð½ÐºÐ° Ñ†Ð²ÐµÑ‚Ð° Ñƒ Ð¿ÑƒÐ½ÐºÑ‚Ð° Ð´ÐµÑ€ÐµÐ²Ð°.

ÐŸÑ€Ð°Ð²Ð°Ñ Ð¿Ð°Ð½ÐµÐ»ÑŒ â€” ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ (Ð±Ð»Ð¾ÐºÐ¸):
  â€¢ Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº (ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ), Ð±ÐµÐ¹Ð´Ð¶ Â«ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑÂ» (Ñ†Ð²ÐµÑ‚ â€” Ð¸Ð· Ñ€Ð°Ð·Ð´ÐµÐ»Ð°), Ð±ÐµÐ¹Ð´Ð¶ Â«ðŸ“Ž NÂ» Ð¿Ñ€Ð¸ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ð¸ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹.
  â€¢ ÐŸÐ¾Ð»Ñ (Ð´Ð¾ N Ð²Ð¸Ð´Ð¸Ð¼Ñ‹Ñ… ÑÑ‚Ñ€Ð¾Ðº Ð½Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐµ), ÐºÐ½Ð¾Ð¿ÐºÐ¸ Â«â†—Â» (Ð¿ÐµÑ€ÐµÐ¹Ñ‚Ð¸ Ð¿Ð¾ URL/mailto), Â«ðŸ—Â» (ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ).
  â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ¸ Ð²Ð½Ð¸Ð·Ñƒ: Â«ðŸ” ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒÂ», Â«â†”ï¸ ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒÂ», Â«ðŸ“ Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÂ», Â«ðŸ“ Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸Â», Â«ðŸ—‘ï¸ Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒÂ».
  â€¢ Â«ðŸ”—Â» â€” Ð¼ÐµÐ½ÑŽ Â«ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑÂ» (ÑÐ¼. 18), Â«QRÂ» â€” Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ QRâ€‘ÐºÐ¾Ð´ Ñ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸.

ÐŸÐµÑ€ÐµÑ‚Ð°ÑÐºÐ¸Ð²Ð°Ð½Ð¸Ðµ:
  â€¢ ÐŸÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÑƒ Ð¼Ñ‹ÑˆÑŒÑŽ Ð½Ð° Ð½ÑƒÐ¶Ð½Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ» ÑÐ»ÐµÐ²Ð° â€” Ð±Ð»Ð¾Ðº Ð¿ÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑÑ.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5) Ð Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð¸ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ (Ð´ÐµÑ€ÐµÐ²Ð¾ ÑÐ»ÐµÐ²Ð°)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ:
  â€¢ Â«+ Ð Ð°Ð·Ð´ÐµÐ»Â» â€” Ð½Ð¾Ð²Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ» Ð²ÐµÑ€Ñ…Ð½ÐµÐ³Ð¾ ÑƒÑ€Ð¾Ð²Ð½Ñ.
  â€¢ Ð’Ñ‹Ð´ÐµÐ»Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ» â†’ Â«+ ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Â» â€” Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ».

ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ/Ñ†Ð²ÐµÑ‚:
  â€¢ ÐŸÐšÐœ Ð¿Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ â†’ Â«ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ñ‚ÑŒÂ» Ð¸Ð»Ð¸ Â«Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ†Ð²ÐµÑ‚Â». Ð¦Ð²ÐµÑ‚ Ð²Ð»Ð¸ÑÐµÑ‚ Ð½Ð° Ð±ÐµÐ¹Ð´Ð¶ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸ Ð±Ð»Ð¾ÐºÐ°.

ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ð½Ð° Ñ€Ð°Ð·Ð´ÐµÐ»:
  â€¢ ÐŸÐšÐœ Ð¿Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ â†’ Â«ðŸ”’ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒÂ» â€” Ð·Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ. Ð”Ð°Ð»ÐµÐµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ ÑÑ‚Ð¾Ð³Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ð° Ð¸ Ð²ÑÐµÑ…
    ÐµÐ³Ð¾ Ð´Ð¾Ñ‡ÐµÑ€Ð½Ð¸Ñ… Ð±ÑƒÐ´ÐµÑ‚ ÑÐºÑ€Ñ‹Ñ‚Ð¾ Ð´Ð¾ Ð²Ð²Ð¾Ð´Ð° Ð¿Ð°Ñ€Ð¾Ð»Ñ (ÑÐ¼. 12).
  â€¢ Ð§Ñ‚Ð¾Ð±Ñ‹ ÑÐ½ÑÑ‚ÑŒ â€” Â«ðŸ”“ Ð¡Ð½ÑÑ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒÂ» (Ð½ÑƒÐ¶ÐµÐ½ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°).

Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚/Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°: ÐŸÐšÐœ â†’ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ð¿ÑƒÐ½ÐºÑ‚.

Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°:
  â€¢ Â«Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒÂ» â€” Ð²ÑÐµ Ð±Ð»Ð¾ÐºÐ¸ Ð¸Ð· Ñ€Ð°Ð·Ð´ÐµÐ»Ð° Ð¸ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰Ð°ÑŽÑ‚ÑÑ Ð² Â«ÐšÐ¾Ñ€Ð·Ð¸Ð½ÑƒÂ» (ÑÐ¼. 11).

Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð²:
  â€¢ Alt+â†‘ / Alt+â†“ â€” Ð¿ÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ» Ð²Ñ‹ÑˆÐµ/Ð½Ð¸Ð¶Ðµ ÑÑ€ÐµÐ´Ð¸ ÑÐ¾ÑÐµÐ´ÐµÐ¹.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6) Ð‘Ð»Ð¾ÐºÐ¸ (ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ ÑÐ¿Ñ€Ð°Ð²Ð°)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ:
  â€¢ Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ» â†’ Â«+ Ð‘Ð»Ð¾ÐºÂ» â†’ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ â†’ Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Â«Ð¨Ð°Ð±Ð»Ð¾Ð½Â» (Ð½Ð°Ð±Ð¾Ñ€ Ð¿Ð¾Ð»ÐµÐ¹).
  â€¢ ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ Ð±Ð»Ð¾ÐºÐ° = Ð¸Ð¼Ñ ÐºÐ¾Ð½ÐµÑ‡Ð½Ð¾Ð³Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ð° (Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ Ð¿ÑƒÑ‚Ð¸).

ÐžÑ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ/Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ:
  â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ° Â«ðŸ” ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒÂ» Ð½Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐµ â€” Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¾Ñ€ Ð±Ð»Ð¾ÐºÐ° (Ð¿Ð¾Ð»Ñ, Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ, Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸, JSONâ€‘Ð²Ð¸Ð´).

ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ:
  â€¢ Â«â†”ï¸ ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒÂ» (Ð´Ð¸Ð°Ð»Ð¾Ð³ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¿ÑƒÑ‚Ð¸) Ð¸Ð»Ð¸ Ð¿ÐµÑ€ÐµÑ‚Ð°ÑÐºÐ¸Ð²Ð°Ð½Ð¸ÐµÐ¼ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð½Ð° Ñ€Ð°Ð·Ð´ÐµÐ» ÑÐ»ÐµÐ²Ð°.

Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ:
  â€¢ Â«ðŸ—‘ï¸ Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒÂ» â€” Ð±Ð»Ð¾Ðº ÑƒÑ…Ð¾Ð´Ð¸Ñ‚ Ð² Â«ÐšÐ¾Ñ€Ð·Ð¸Ð½ÑƒÂ», Ð¼Ð¾Ð¶Ð½Ð¾ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ (ÑÐ¼. 11).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
7) ÐŸÐ¾Ð»Ñ: Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ, Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ, ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ, ÑÑÑ‹Ð»ÐºÐ¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Ð’ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¼ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¾Ñ€Ðµ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Â«Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»ÐµÂ», Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ â€” Ð¿Ð¾ÑÐ²Ð¸Ñ‚ÑÑ Ð½Ð¾Ð²Ð°Ñ Ð¿Ð°Ñ€Ð°.
â€¢ Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÐµÐ¹ Ð²ÑÐµÐ³Ð´Ð° Ñ…Ñ€Ð°Ð½ÑÑ‚ÑÑ Ð² Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¼ Ð²Ð¸Ð´Ðµ. ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Â«ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹ÐµÂ» Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚
  Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÑƒ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ°Ñ….
â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ° Â«ðŸ—Â» Ñ€ÑÐ´Ð¾Ð¼ ÑÐ¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÐµÐ¼ â€” ÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐµÑ‚ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð° (Ñ‡ÐµÑ€ÐµÐ· 30 ÑÐµÐºÑƒÐ½Ð´
  Ð±ÑƒÑ„ÐµÑ€ Ð¾Ñ‡Ð¸Ñ‰Ð°ÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸).
â€¢ Ð•ÑÐ»Ð¸ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ñ…Ð¾Ð¶Ðµ Ð½Ð° URL Ð¸Ð»Ð¸ email, Ð¿Ð¾ÑÐ²Ð¸Ñ‚ÑÑ Â«â†—Â» â€” Ð¾Ñ‚ÐºÑ€Ð¾ÐµÑ‚ ÑÑÑ‹Ð»ÐºÑƒ/Ð¿Ð¾Ñ‡Ñ‚Ð¾Ð²Ñ‹Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚.
â€¢ ÐšÐ½Ð¾Ð¿ÐºÐ° Â«ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²ÑÐµ Ð¿Ð¾Ð»Ñ Ð² Ð±ÑƒÑ„ÐµÑ€Â» ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº, Ð²ÑÐµ Ð¿Ð¾Ð»Ñ Ð¸ Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸ Ð² Ñ‚ÐµÐºÑÑ‚.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
8) Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ (Ñ„Ð°Ð¹Ð»Ñ‹): Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ, Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€, Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ°, ÑˆÐ°Ñ€Ð¸Ð½Ð³
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Ð’ÐºÐ»Ð°Ð´ÐºÐ° Â«Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÂ» Ð² Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¼ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¾Ñ€Ðµ:
  â€“ Â«Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»Â» â€” ÑˆÐ¸Ñ„Ñ€ÑƒÐµÑ‚ÑÑ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ÑÑ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ Ð¿Ð°Ð¿ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ….
  â€“ Â«Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÐºÐ°Ðºâ€¦Â» â€” Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð» Ð½Ð° Ð´Ð¸ÑÐº.
  â€“ Â«Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸ÐµÂ» â€” ÑƒÐ´Ð°Ð»ÑÐµÑ‚ Ñ„Ð°Ð¹Ð» Ð¸Ð· Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ð°.
  â€“ ÐŸÑ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€: Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð¸ Ð¼ÐµÐ»ÐºÐ¸Ðµ Ñ‚ÐµÐºÑÑ‚Ñ‹ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÑŽÑ‚ÑÑ; Ð±Ð¾Ð»ÑŒÑˆÐ¸Ðµ/Ð½ÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ðµ â€” Ð±ÐµÐ· Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð°.
â€¢ Â«ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑÂ» (Ð¼ÐµÐ½ÑŽ: Telegram, WhatsApp, Email) Ð³Ð¾Ñ‚Ð¾Ð²Ð¸Ñ‚ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½ÑƒÑŽ ÐºÐ¾Ð¿Ð¸ÑŽ Ð² Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾Ð¹
  Ð¿Ð°Ð¿ÐºÐµ. Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð¿Ð°Ð¿ÐºÐ° ÑƒÐ´Ð°Ð»ÑÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ñ‡ÐµÑ€ÐµÐ· 60 ÑÐµÐºÑƒÐ½Ð´ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
9) Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸ Ð¿Ð¾ Ð±Ð»Ð¾ÐºÑƒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Ð’ÐºÐ»Ð°Ð´ÐºÐ° Â«Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸Â» â€” ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ñ‹Ð¹ ÑˆÐ¸Ñ„Ñ€ÑƒÐµÐ¼Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚, Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ ÐºÐ°Ðº ÐµÐ´Ð¸Ð½Ð¾Ðµ Ð¿Ð¾Ð»Ðµ, Ð¸Ð½Ð´ÐµÐºÑÐ¸Ñ€ÑƒÐµÑ‚ÑÑ Ð¿Ð¾Ð¸ÑÐºÐ¾Ð¼.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
10) ÐŸÐ¾Ð¸ÑÐº Ð¸ Â«Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸Â»
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐŸÐ¾Ð¸ÑÐº:
  â€¢ Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð² Ð¿Ð¾Ð»Ðµ Â«ÐŸÐ¾Ð¸ÑÐºâ€¦Â».
  â€¢ Ð ÐµÐ¶Ð¸Ð¼ Â«Ð‘Ð»Ð¾ÐºÐ¸Â» â€” Ð¸Ñ‰ÐµÑ‚ Ð¿Ð¾ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÑƒ/ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸/ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ð¼Ñƒ (Ð¸Ð½Ð´ÐµÐºÑÑƒ) Ð±Ð»Ð¾ÐºÐ°.
  â€¢ Ð ÐµÐ¶Ð¸Ð¼ Â«ÐŸÐ¾Ð»ÑÂ» â€” Ð¸Ñ‰ÐµÑ‚ Ð¿Ð¾ Ð¸Ð¼ÐµÐ½Ð°Ð¼ Ð¿Ð¾Ð»ÐµÐ¹ Ð¸ Ð¸Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑÐ¼ (Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸).

Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸:
  â€¢ Â«ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ â†’ ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸Â»: ÑÐ¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð¾ (Ð¸Ð¼Ñ, Ð·Ð°Ð¿Ñ€Ð¾Ñ, Ð¾Ð±Ð»Ð°ÑÑ‚ÑŒ â€” Ð²ÐµÑÑŒ ÐºÐ¾Ñ€ÐµÐ½ÑŒ Ð¸Ð»Ð¸ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ»,
    Ñ€ÐµÐ¶Ð¸Ð¼ Â«ÐŸÐ¾Ð»Ñ/Ð‘Ð»Ð¾ÐºÐ¸Â»).
  â€¢ Ð’ Ð´ÐµÑ€ÐµÐ²Ðµ ÑÐ»ÐµÐ²Ð° Ð¿Ð¾ÑÐ²Ð¸Ñ‚ÑÑ Ð²ÐµÑ‚ÐºÐ° Â«ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸Â», Ð²Ð½ÑƒÑ‚Ñ€Ð¸ â€” Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ð¾Ð´Ð±Ð¾Ñ€ÐºÐ¸.

ÐŸÑ€Ð¸Ð¼ÐµÑ‡Ð°Ð½Ð¸Ñ:
  â€¢ ÐŸÑ€Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¼ Ñ‡Ð¸ÑÐ»Ðµ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐµÐº Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð¿ÐµÑ€Ð²Ñ‹Ðµ 300, Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐºÑ€Ñ‹Ñ‚Ñ‹ â€” ÑƒÑ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ Ð·Ð°Ð¿Ñ€Ð¾Ñ.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
11) ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ, ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ¾Ð²: Ð¿ÐµÑ€ÐµÑ‚Ð°ÑÐºÐ¸Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð½Ð° Ñ€Ð°Ð·Ð´ÐµÐ» ÑÐ»ÐµÐ²Ð° Ð¸Ð»Ð¸ Â«â†”ï¸ ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒÂ».
â€¢ Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°/Ñ€Ð°Ð·Ð´ÐµÐ»Ð°: Ð¿ÐµÑ€ÐµÐ½Ð¾Ñ Ð² Â«ÐšÐ¾Ñ€Ð·Ð¸Ð½ÑƒÂ» (Ð¼ÐµÐ½ÑŽ Â«ðŸ—‘ï¸ ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°Â»). Ð’ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ðµ:
  â€“ Â«Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹Â» â€” Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð±Ð»Ð¾Ðº Ð² Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ».
  â€“ Â«ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€)Â» â€” Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€.
  â€“ Â«ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½ÑƒÂ» â€” ÑƒÐ´Ð°Ð»ÑÐµÑ‚ Ð±ÐµÐ·Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚Ð½Ð¾ (Ð¿Ð¾Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
12) Ð—Ð°Ñ‰Ð¸Ñ‚Ð° Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð² Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼, Ñ€Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ñ†ÐµÐ¿Ð¾Ñ‡ÐºÐ¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ÐŸÐšÐœ Ð¿Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ â†’ Â«ðŸ”’ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒÂ». Ð’ÑÐµ Ð´Ð¾Ñ‡ÐµÑ€Ð½Ð¸Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð½Ð°ÑÐ»ÐµÐ´ÑƒÑŽÑ‚ Ð·Ð°Ñ‰Ð¸Ñ‚Ñƒ.
â€¢ Ð”Ð»Ñ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð±Ð»Ð¾ÐºÐ¾Ð² Ð²Ð½ÑƒÑ‚Ñ€Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‰Ñ‘Ð½Ð½Ð¾Ð¹ Ð²ÐµÑ‚ÐºÐ¸:
  â€“ ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Â«ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹ÐµÂ» Ð½Ð° Ð¿Ð°Ð½ÐµÐ»Ð¸.
  â€“ Ð’ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¼ Ñ€Ð°Ð·Ð´ÐµÐ»Ðµ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐµ Ð±ÑƒÐ´ÐµÑ‚ Â«ðŸ”“Â» â€” Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð¸ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°.
â€¢ Â«ðŸ”“ Ð¡Ð½ÑÑ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒÂ» â€” Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾ÑÐ»Ðµ Ð²Ð²Ð¾Ð´Ð° Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð¿Ð°Ñ€Ð¾Ð»Ñ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
13) Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… (XLSX/CSV/JSON/TXT)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐœÐµÐ½ÑŽ: Â«Ð¤Ð°Ð¹Ð» â†’ ðŸ“¥ Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ (Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹)Â».
ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ñ‹ Ð¸ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð°:
â€¢ Excel (.xlsx): Ð¿ÐµÑ€Ð²Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ° â€” Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸. Â«ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°Â», Â«Ð Ð°Ð·Ð´ÐµÐ»/ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»/ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Â» Ð¸Ð»Ð¸ Â«ÐŸÑƒÑ‚ÑŒÂ».
â€¢ CSV (.csv): Ñ€Ð°Ð·Ð´ÐµÐ»Ð¸Ñ‚ÐµÐ»ÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ (Ð·Ð°Ð¿ÑÑ‚Ð°Ñ, Ñ‚Ð¾Ñ‡ÐºÐ° Ñ Ð·Ð°Ð¿ÑÑ‚Ð¾Ð¹, Ñ‚Ð°Ð±, Ð²ÐµÑ€Ñ‚Ð¸ÐºÐ°Ð»ÑŒÐ½Ð°Ñ Ñ‡ÐµÑ€Ñ‚Ð°).
â€¢ JSON:
  a) { "A/B/C": [ {block}, ... ], ... }
  b) [ {"Ð Ð°Ð·Ð´ÐµÐ»":"â€¦","ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»":"â€¦","ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°":"â€¦", ...}, ... ]
  c) [ {"ÐŸÑƒÑ‚ÑŒ":"A/B/C","ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°":"â€¦", ...}, ... ]
â€¢ TXT: Ð¿ÐµÑ€Ð²Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ° â€” Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸, Ð´Ð°Ð»ÐµÐµ ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ Â«|Â»-Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‘Ð½Ð½Ñ‹Ñ… ÑÑ‚Ð¾Ð»Ð±Ñ†Ð¾Ð².

ÐœÐ°Ð¿Ð¿Ð¸Ð½Ð³:
â€¢ Ð•ÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Â«ÐŸÑƒÑ‚ÑŒÂ», Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð¾Ð½ (Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Â«/Â»).
â€¢ Ð˜Ð½Ð°Ñ‡Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ÑÑ Â«Ð Ð°Ð·Ð´ÐµÐ»/ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»/ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Â».
â€¢ ÐžÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÑ‚Ð¾Ð»Ð±Ñ†Ñ‹ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ ÐºÐ°Ðº Ð¿Ð¾Ð»Ñ Ð±Ð»Ð¾ÐºÐ°. ÐŸÑƒÑÑ‚Ñ‹Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
14) Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…: Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹ Ð¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ (LPX1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐžÐ±Ñ‹Ñ‡Ð½Ñ‹Ð¹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚: Â«Ð¤Ð°Ð¹Ð» â†’ ðŸ“¤ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ (Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹)Â» â†’ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ (XLSX/CSV/JSON/TXT/HTML).  
Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚ (LPX1): Â«Ð¤Ð°Ð¹Ð» â†’ ðŸ” Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ (ÑˆÐ¸Ñ„Ñ€.)Â» â†’ Ð·Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ. ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑÑ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€.
Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°: ÐŸÐšÐœ Ð¿Ð¾ Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ â†’ Â«ðŸ“¤ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»â€¦Â».

Ð’Ð°Ð¶Ð½Ð¾:
â€¢ Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚ (LPX1) â€” Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» Ñ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼, Ð¿Ñ€Ð¸Ð³Ð¾Ð´ÐµÐ½ Ð´Ð»Ñ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð¿ÐµÑ€ÐµÐ´Ð°Ñ‡Ð¸.
â€¢ Â«Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ (ÑˆÐ¸Ñ„Ñ€.)Â» Ð¿Ñ€ÐµÐ´Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½ Ð´Ð»Ñ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ñ‹Ñ… ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¾Ð² Ñ‚Ð¾Ð¹ Ð¶Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸. Ð”Ð»Ñ Â«ÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ñ‹Ñ…Â»
  Ð±ÑÐºÐ°Ð¿Ð¾Ð² Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ» 15.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
15) Ð‘ÑÐºÐ°Ð¿ Ð¸ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ (LPX1/LPBK/LPEX/ZIP)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð‘ÑÐºÐ°Ð¿ (Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹):
â€¢ Â«Ð¤Ð°Ð¹Ð» â†’ ðŸ—„ï¸ Ð‘ÑÐºÐ°Ð¿ â†’ ðŸ—„ï¸ Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð±ÑÐºÐ°Ð¿ (ÑˆÐ¸Ñ„Ñ€.)Â» â†’ Ð·Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ â†’ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ .lpx (LPX1).
â€¢ Ð’Ð½ÑƒÑ‚Ñ€Ð¸ â€” zipâ€‘ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ Ñ Ð¿Ð¾Ð»Ð½Ñ‹Ð¼ ÑÐ½Ð¸Ð¼ÐºÐ¾Ð¼ Ð¿Ð°Ð¿ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… (Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ).

Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ:
â€¢ Â«Ð¤Ð°Ð¹Ð» â†’ ðŸ—„ï¸ Ð‘ÑÐºÐ°Ð¿ â†’ â™»ï¸ Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°Â» â†’ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ .lpx/.lpbk/.lpex/.zip.
â€¢ Ð•ÑÐ»Ð¸ Ñ„Ð°Ð¹Ð» Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½ â€” Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð±ÑÐºÐ°Ð¿Ð°.
â€¢ ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ñ€Ð°ÑÐ¿Ð°ÐºÑƒÐµÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð²Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð¿Ð°Ð¿ÐºÑƒ Ð¸ Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶Ð¸Ñ‚ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ (Ð¿ÐµÑ€ÐµÐ´ ÑÑ‚Ð¸Ð¼
  ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚ÑÑ Ñ€ÐµÐ·ÐµÑ€Ð²Ð½Ð°Ñ ÐºÐ¾Ð¿Ð¸Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ).
â€¢ ÐŸÐ¾ÑÐ»Ðµ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ, ÐµÑÐ»Ð¸ Â«auth.jsonÂ» Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð° Ð¾Ñ‚Ð»Ð¸Ñ‡Ð°ÐµÑ‚ÑÑ, Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ
  Ñ‚Ð¾Ð³Ð¾ Ð±ÑÐºÐ°Ð¿Ð° (Ñ‚Ð¾ ÐµÑÑ‚ÑŒ Ñ‚Ð¾Ñ‚, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¾Ð²Ð°Ð» Ð½Ð° Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð±ÑÐºÐ°Ð¿Ð°). Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÐ³Ð¾.
â€¢ ÐŸÐ¾ÑÐ»Ðµ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾Ð³Ð¾ Ð²Ñ…Ð¾Ð´Ð° Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÑÐ¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð½Ð° Ð½Ð¾Ð²Ñ‹Ð¹ (ÑÐ¼. 16).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
16) Ð¡Ð¼ÐµÐ½Ð° Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐœÐµÐ½ÑŽ: Â«ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ â†’ ðŸ—ï¸ Ð¡Ð¼ÐµÐ½Ð° Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑÂ».
â€¢ Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¸ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚Ðµ.
â€¢ Ð’ÑÐµ Ð¿Ð¾Ð»Ñ Ð¸ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿ÐµÑ€Ðµâ€‘Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð¿Ð¾Ð´ Ð½Ð¾Ð²Ñ‹Ð¼ ÐºÐ»ÑŽÑ‡Ð¾Ð¼.
â€¢ ÐÐ° Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ñ‚ÑŒÑÑ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ (Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ Ð¿Ñ€Ð¸ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
17) ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ KDF (Argon2id): Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð¸ Ð¼Ð¸Ð³Ñ€Ð°Ñ†Ð¸Ñ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ ÐšÐ»ÑŽÑ‡ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ÑÑ Ð¸Ð· Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ Ñ‡ÐµÑ€ÐµÐ· KDF Argon2id (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼Ð¸,
  ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¾Ð¼ ÑÐ±Ð¾Ñ€ÐºÐ¸).
â€¢ ÐŸÑ€Ð¸ ÑÑ‚Ð°Ñ€Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶Ð¸Ñ‚ÑŒ Â«ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ KDFâ€¦Â» Ð´Ð¾ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼Ñ‹Ñ…. Ð¡Ð¾Ð³Ð»Ð°ÑÐ¸Ñ‚ÐµÑÑŒ â€”
  Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿ÐµÑ€Ðµâ€‘Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ñ Ð½Ð¾Ð²Ñ‹Ð¼ KDF.
â€¢ Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸/ÑÐºÐ¾Ñ€Ð¾ÑÑ‚Ð¸: t=4, m=128MiB, p=2.
â€¢ Ð¡Ð¼ÐµÐ½Ð° KDF Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ñ‡ÐµÑ€ÐµÐ· Â«Ð¼Ð¸Ð³Ñ€Ð°Ñ†Ð¸ÑŽÂ»: ÑÑ‚Ð°Ñ€Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð¸ ÑˆÐ¸Ñ„Ñ€ÑƒÑŽÑ‚ÑÑ Ð·Ð°Ð½Ð¾Ð²Ð¾.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
18) ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸: Telegram / WhatsApp / Email
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð¢ÐµÐºÑÑ‚:
â€¢ ÐÐ° ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐµ Ð±Ð»Ð¾ÐºÐ° â€” Â«ðŸ”—Â» â†’ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ°Ð½Ð°Ð» (Telegram/WhatsApp/Email). Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ñ‚ÐµÐºÑÑ‚ Ñ Ð¿Ð¾Ð»ÑÐ¼Ð¸.
â€¢ Ð•ÑÐ»Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚ Ð½Ðµ Ð¾Ñ‚ÐºÑ€Ñ‹Ð²Ð°ÐµÑ‚ÑÑ, Ñ‚ÐµÐºÑÑ‚ ÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð° (Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ).

Ð¤Ð°Ð¹Ð»Ñ‹:
â€¢ Ð’ Â«Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÂ» â†’ Ð¸ÐºÐ¾Ð½ÐºÐ° Â«Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑÂ» â†’ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Telegram/WhatsApp/Email.
â€¢ Ð”Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚ÑÑ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð¿Ð°Ð¿ÐºÐ° Ñ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ñ„Ð°Ð¹Ð»Ð°Ð¼Ð¸ (ÑƒÐ´Ð°Ð»ÑÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ñ‡ÐµÑ€ÐµÐ·
  ~60 ÑÐµÐºÑƒÐ½Ð´). ÐžÑ‚ÐºÑ€Ð¾ÐµÑ‚ÑÑ Ð¿Ñ€Ð¾Ð²Ð¾Ð´Ð½Ð¸Ðº/Ñ‡Ð°Ñ‚Ñ‹ â€” Ð¿ÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»Ñ‹.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
19) Ð“Ð¾Ñ€ÑÑ‡Ð¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑˆÐ¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Alt+â†‘ / Alt+â†“ â€” Ð¿Ð¾Ð´Ð½ÑÑ‚ÑŒ/Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ» Ð² Ð´ÐµÑ€ÐµÐ²Ðµ.
â€¢ Ctrl+R â€” ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ».
â€¢ Ctrl+P â€” ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ».
â€¢ Ctrl+B â€” ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð±Ð»Ð¾Ðº.
â€¢ Ctrl+Q â€” Ð²Ñ‹Ñ…Ð¾Ð´ Ð¸Ð· Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹.
(Ð”Ñ€ÑƒÐ³Ð¸Ðµ ÑˆÐ¾Ñ€Ñ‚ÐºÐ°Ñ‚Ñ‹ Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ‹ Ð²Ð°ÑˆÐµÐ¹ ÑÐ±Ð¾Ñ€ÐºÐ¾Ð¹.)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
20) ÐŸÐ°Ð¿ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸ Ð¿ÐµÑ€ÐµÐ½Ð¾Ñ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¾Ð¹ ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐŸÐ°Ð¿ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… (ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸):
â€¢ Windows: %APPDATA%\\LinkPass
â€¢ macOS:  ~/Library/Application Support/LinkPass
â€¢ Linux:  ~/.local/share/LinkPass

Ð’Ð½ÑƒÑ‚Ñ€Ð¸ Ð½Ð°Ñ…Ð¾Ð´ÑÑ‚ÑÑ: tree.json, blocks.json, trash.json, meta.json, auth.json, index.db, Ð¿Ð°Ð¿ÐºÐ° attachments/
(Ð²ÑÑ‘, ÐºÑ€Ð¾Ð¼Ðµ auth.json Ð¸ index.db, Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ð² Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¼ Ð²Ð¸Ð´Ðµ).
ÐŸÐµÑ€ÐµÐ½Ð¾Ñ:
â€¢ Ð—Ð°ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ Ð½Ð° Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð¼ ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€Ðµ.
â€¢ Ð¡ÐºÐ¾Ð¿Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð²ÑÑŽ Ð¿Ð°Ð¿ÐºÑƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ†ÐµÐ»Ð¸ÐºÐ¾Ð¼ Ð½Ð° Ð½Ð¾Ð²Ñ‹Ð¹ ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€ Ð² ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐµ Ð¼ÐµÑÑ‚Ð¾.
â€¢ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ/Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ LinkPass Ð¸ Ð²Ð¾Ð¹Ð´Ð¸Ñ‚Ðµ ÑÐ²Ð¾Ð¸Ð¼ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼.
Ð’Ð°Ð¶Ð½Ð¾:
â€¢ Ð•ÑÐ»Ð¸ Ð¿Ñ€Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð»Ð°ÑÑŒ Â«pepperÂ» (Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ LINKPASS_PEPPER_B64), Ð½Ð° Ð½Ð¾Ð²Ð¾Ð¼
  ÐŸÐš ÐµÑ‘ Ð½ÑƒÐ¶Ð½Ð¾ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ñ Ñ‚ÐµÐ¼ Ð¶Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÐµÐ¼ â€” Ð¸Ð½Ð°Ñ‡Ðµ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ° Ð±ÑƒÐ´ÐµÑ‚ Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð°.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
21) Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ ÑƒÑ‚Ñ€Ð°Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ â€” Ñ‡Ñ‚Ð¾ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ÐšÐ¾Ñ€Ð¾Ñ‚ÐºÐ¾: Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð½Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑÑ Ð¸ Ð½Ðµ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ÑÑ. Ð‘ÐµÐ· Ð½ÐµÐ³Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð½ÐµÐ»ÑŒÐ·Ñ.
Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ ÑÑ†ÐµÐ½Ð°Ñ€Ð¸Ð¸:
A) Ð•ÑÑ‚ÑŒ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿ (.lpx/.lpbk/.lpex) Ð¸ Ð¸Ð·Ð²ÐµÑÑ‚ÐµÐ½ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð±ÑÐºÐ°Ð¿Ð°:
   1. Â«Ð¤Ð°Ð¹Ð» â†’ Ð‘ÑÐºÐ°Ð¿ â†’ â™»ï¸ Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°Â».
   2. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð±ÑÐºÐ°Ð¿Ð°.
   3. Ð•ÑÐ»Ð¸ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ auth.json â€” Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ,
      ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¾Ð²Ð°Ð» Ð² Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð±ÑÐºÐ°Ð¿Ð°. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐµÐ³Ð¾.
   4. ÐŸÐ¾ÑÐ»Ðµ Ð²Ñ…Ð¾Ð´Ð° ÑÑ€Ð°Ð·Ñƒ ÑÐ¼ÐµÐ½Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð½Ð° Ð½Ð¾Ð²Ñ‹Ð¹ (ÑÐ¼. 16).

B) Ð•ÑÑ‚ÑŒ Ð¿Ð¾Ð»Ð½Ð°Ñ ÐºÐ¾Ð¿Ð¸Ñ Ð¿Ð°Ð¿ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… (Time Machine, Ñ„Ð°Ð¹Ð»Ð¾Ð²Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿ Ð¸ Ñ‚. Ð¿.) Ð¾Ñ‚ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚Ð°, ÐºÐ¾Ð³Ð´Ð° Ð¿Ð°Ñ€Ð¾Ð»ÑŒ ÐµÑ‰Ñ‘ Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚Ðµ:
   1. Ð—Ð°ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ. Ð¡Ð´ÐµÐ»Ð°Ð¹Ñ‚Ðµ Ñ€ÐµÐ·ÐµÑ€Ð²Ð½ÑƒÑŽ ÐºÐ¾Ð¿Ð¸ÑŽ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¹ Ð¿Ð°Ð¿ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ….
   2. Ð’ÐµÑ€Ð½Ð¸Ñ‚Ðµ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð° Ð²ÑÑŽ Ð¿Ð°Ð¿ÐºÑƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… LinkPass Ñ†ÐµÐ»Ð¸ÐºÐ¾Ð¼.
   3. Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ LinkPass Ð¸ Ð²Ð¾Ð¹Ð´Ð¸Ñ‚Ðµ ÑÑ‚Ð°Ñ€Ñ‹Ð¼ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼.
   4. Ð¡Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ (ÑÐ¼. 16).

C) ÐÐµÑ‚ Ð±ÑÐºÐ°Ð¿Ð° Ð¸ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð·Ð°Ð±Ñ‹Ñ‚:
   â€¢ Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ñƒ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð½ÐµÐ»ÑŒÐ·Ñ (Ñ‚Ð°Ðº Ð·Ð°Ð´ÑƒÐ¼Ð°Ð½Ð° Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ).
   â€¢ Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð½Ð¾Ð²Ð¾Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ:
     â€“ Ð—Ð°ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ. ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½ÑƒÐ¹Ñ‚Ðµ Ñ‚ÐµÐºÑƒÑ‰ÑƒÑŽ Ð¿Ð°Ð¿ÐºÑƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² LinkPass_backup_YYYYMMDD.
     â€“ Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ LinkPass â€” Ð±ÑƒÐ´ÐµÑ‚ Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¾ Ð·Ð°Ð´Ð°Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.
     â€“ Ð•ÑÐ»Ð¸ Ñƒ Ð²Ð°Ñ ÐµÑÑ‚ÑŒ Ð»ÑŽÐ±Ñ‹Ðµ Ð¿Ñ€ÐµÐ¶Ð½Ð¸Ðµ EXCEL/CSV/JSON/TXTâ€‘ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ñ‹ Ð² Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¾Ð¼ Ð²Ð¸Ð´Ðµ â€” Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð¸Ñ… (ÑÐ¼. 13).

Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸:
â€¢ Ð¡Ñ€Ð°Ð·Ñƒ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹Ñ‚Ðµ Ñ€ÐµÐ³ÑƒÐ»ÑÑ€Ð½Ñ‹Ðµ Ð±ÑÐºÐ°Ð¿Ñ‹ (ÑÐ¼. Ð½Ð¸Ð¶Ðµ), Ñ…Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»Ð¸ Ð±ÑÐºÐ°Ð¿Ð¾Ð² Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ñ‚ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ.
â€¢ Ð¥Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ LINKPASS_PEPPER_B64 (ÐµÑÐ»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð»Ð¸) Ð² Ð½Ð°Ð´Ñ‘Ð¶Ð½Ð¾Ð¼ Ð¼ÐµÑÑ‚Ðµ.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
22) Ð¡Ð¾Ð²ÐµÑ‚Ñ‹ Ð¿Ð¾ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¸ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ ÐµÐ³Ð¾ Ð½Ð¸Ð³Ð´Ðµ Ð±Ð¾Ð»ÑŒÑˆÐµ.
â€¢ Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ Ñ€ÐµÐ³ÑƒÐ»ÑÑ€Ð½Ñ‹Ð¹ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿:
  â€“ Â«ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ â†’ â±ï¸ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð¿Ð¾ Ñ€Ð°ÑÐ¿Ð¸ÑÐ°Ð½Ð¸ÑŽÂ» â€” Ð·Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ð¿ÐºÑƒ Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ LPX1â€‘ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð°.
â€¢ Ð—Ð°Ñ‰Ð¸Ñ‰Ð°Ð¹Ñ‚Ðµ Ñ‡ÑƒÐ²ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð²ÐµÑ‚ÐºÐ¸ Ð´ÐµÑ€ÐµÐ²Ð° Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ð¼Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑÐ¼Ð¸ Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð².
â€¢ Ð¥Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð±ÑÐºÐ°Ð¿Ñ‹ Ð¸ Â«pepperÂ» Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ñ‚ Ñ€Ð°Ð±Ð¾Ñ‡ÐµÐ³Ð¾ ÐŸÐš.
â€¢ ÐŸÑ€Ð¸ ÑˆÐ°Ñ€Ð¸Ð½Ð³Ðµ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ ÐºÐ¾Ð¿Ð¸Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚ ÐºÐ¾Ñ€Ð¾Ñ‚ÐºÐ¾Ðµ Ð²Ñ€ÐµÐ¼Ñ Ð²
  ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ð¾Ð¹ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð¿Ð°Ð¿ÐºÐµ.



  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚ LinkPass
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ð•ÑÐ»Ð¸ Ð²Ð°Ð¼ Ð¿Ð¾Ð»ÐµÐ·ÐµÐ½ LinkPass, Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ Ð´Ð¾Ð±Ñ€Ð¾Ð²Ð¾Ð»ÑŒÐ½Ñ‹Ð¼ Ð¿Ð¾Ð¶ÐµÑ€Ñ‚Ð²Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼.

- YooMoney: **https://yoomoney.ru/to/410011663886937**
- Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ ÐºÐ½Ð¾Ð¿ÐºÐ°: [![Donate](https://img.shields.io/badge/Donate-YooMoney-6c3adb?logo=yoomoney)](https://yoomoney.ru/to/410011663886937)

Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾! Ð›ÑŽÐ±Ð°Ñ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÐµÑ‚ ÑƒÑÐºÐ¾Ñ€ÑÑ‚ÑŒ Ñ€Ð°Ð·Ð²Ð¸Ñ‚Ð¸Ðµ Ð¸ ÑƒÐ´ÐµÐ»ÑÑ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ñ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ñƒ Ð¸ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ð¸.
"""

LICENSE_TEXT = """\
ÐŸÑ€Ð°Ð²Ð¾Ð²Ñ‹Ðµ ÑÐ²ÐµÐ´ÐµÐ½Ð¸Ñ
â€¢ ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÑÐµÑ‚ÑÑ Ð¿Ð¾ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ MIT. ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚ (Ð½Ð° Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¾Ð¼) Ð½Ð¸Ð¶Ðµ Ð±ÐµÐ· ÐºÐ°ÐºÐ¸Ñ…â€‘Ð»Ð¸Ð±Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹.
â€¢ Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ (ÐÐ• Ñ‡Ð°ÑÑ‚ÑŒ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸ MIT, Ð° Ñ€Ð°Ð·ÑŠÑÑÐ½ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ):
  â€“ ÐŸÐž Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ÑÑ Â«ÐºÐ°Ðº ÐµÑÑ‚ÑŒÂ», Ð±ÐµÐ· ÐºÐ°ÐºÐ¸Ñ…â€‘Ð»Ð¸Ð±Ð¾ Ð¾Ð±ÐµÑ‰Ð°Ð½Ð¸Ð¹ Ð¿Ñ€Ð¸Ð³Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸, Ñ€Ð°Ð±Ð¾Ñ‚Ð¾ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸, ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ñ Ñ†ÐµÐ»ÑÐ¼ Ð¸Ð»Ð¸ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸.
  â€“ ÐÐ²Ñ‚Ð¾Ñ€/Ð¿Ñ€Ð°Ð²Ð¾Ð¾Ð±Ð»Ð°Ð´Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ ÑÐ¾Ð¿Ñ€Ð¾Ð²Ð¾Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÑƒ, Ð½Ðµ Ð½ÐµÑÑ‘Ñ‚ Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸ Ð·Ð° Ð¿Ñ€ÑÐ¼Ð¾Ð¹/ÐºÐ¾ÑÐ²ÐµÐ½Ð½Ñ‹Ð¹/ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ð¹/ÐºÐ¾ÑÐ²ÐµÐ½Ð½Ð¾â€‘Ð²Ñ‹Ñ‚ÐµÐºÐ°ÑŽÑ‰Ð¸Ð¹ ÑƒÑ‰ÐµÑ€Ð±, Ð¿Ð¾Ñ‚ÐµÑ€ÑŽ Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð¿ÐµÑ€ÐµÐ±Ð¾Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹, Ð° Ñ‚Ð°ÐºÐ¶Ðµ Ð·Ð° Ð¿Ð¾ÑÐ»ÐµÐ´ÑÑ‚Ð²Ð¸Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð² ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð²Ð°Ð¶Ð½Ñ‹Ñ… ÑÐ¸ÑÑ‚ÐµÐ¼Ð°Ñ… (Ð¼ÐµÐ´Ð¸Ñ†Ð¸Ð½Ð°, Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚, ÑÐ½ÐµÑ€Ð³Ð¾ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ Ð¸ Ñ‚. Ð¿.).
  â€“ Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° ÑÐ²Ð¾Ð¹ Ñ€Ð¸ÑÐº. ÐžÑ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ Ð°Ð²Ñ‚Ð¾Ñ€Ð° Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð°.


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MIT License (canonical English text)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MIT License

Copyright (c) 2025 Savin Evgenii

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Thirdâ€‘party notices (licenses/links)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ PySide6 â€” Qt for Python (LGPLv3): https://doc.qt.io/qtforpython/
â€¢ cryptography (Apache 2.0): https://cryptography.io/
â€¢ pandas (BSDâ€‘3â€‘Clause): https://pandas.pydata.org/
â€¢ openpyxl (MIT): https://openpyxl.readthedocs.io/
â€¢ argon2â€‘cffi (MIT): https://github.com/hynek/argon2-cffi
â€¢ Pillow / PIL (HPND/PIL License): https://python-pillow.org/
â€¢ pyotp (MIT): https://pyauth.github.io/pyotp/
â€¢ qrcode (BSD): https://github.com/lincolnloop/python-qrcode

ÐŸÑ€Ð¸Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ: Ñ‚ÐµÐºÑÑ‚Ñ‹ ÑÑ‚Ð¾Ñ€Ð¾Ð½Ð½Ð¸Ñ… Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹ Ð¿Ð¾ Ð¿Ñ€Ð¸Ð²ÐµÐ´Ñ‘Ð½Ð½Ñ‹Ð¼ ÑÑÑ‹Ð»ÐºÐ°Ð¼. ÐŸÑ€Ð¸ Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð¸Ð¸ ÑÐ±Ð¾Ñ€Ð¾Ðº,
ÑÐ¾Ð±Ð»ÑŽÐ´Ð°Ð¹Ñ‚Ðµ ÑƒÑÐ»Ð¾Ð²Ð¸Ñ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ñ… Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¹.
"""
def audit_write(action: str, details: dict):
    return
def install_crash_handler():
    def _hook(exctype, exc, tb):
        if issubclass(exctype, (KeyboardInterrupt, SystemExit)):
            try:
                app = QCoreApplication.instance()
                if app is not None:
                    QCoreApplication.quit()
            except Exception:
                pass
            return
        msg = "".join(traceback.format_exception(exctype, exc, tb))
        try:
            with open(os.path.join(DATA_DIR, "crash.log"), "a", encoding="utf-8") as f:
                f.write(f"[{datetime.now().isoformat()}] {msg}\n\n")
        except Exception:
            pass
        try:
            from PySide6.QtWidgets import QApplication, QMessageBox
            app = QApplication.instance()
        except Exception:
            app = None
        if app is not None:
            try:
                QMessageBox.critical(
                    None, "ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°",
                    "Ð’Ð¾Ð·Ð½Ð¸ÐºÐ»Ð° Ð½ÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°. Ð¤Ð°Ð¹Ð» crash.log ÑÐ¾Ñ…Ñ€Ð°Ð½Ñ‘Ð½ Ð² Ð¿Ð°Ð¿ÐºÐµ Ð´Ð°Ð½Ð½Ñ‹Ñ….\n\n"
                    + (msg[:2000])
                )
            except Exception:
        
                try:
                    print("[LinkPass] FATAL:\n" + msg, file=sys.stderr)
                except Exception:
                    pass
        else:
            try:
                print("[LinkPass] FATAL:\n" + msg, file=sys.stderr)
            except Exception:
                pass
    sys.excepthook = _hook
def install_sigint_quit():
    try:
        signal.signal(signal.SIGINT, lambda *_: QCoreApplication.quit())
    except Exception:
        pass
install_crash_handler()
install_sigint_quit()
def rand_bytes(n: int) -> bytes:
    return secrets.token_bytes(n)
def pbkdf2_key(master: str, salt: bytes, length=32, iterations=300_000) -> bytes:
    return hashlib.pbkdf2_hmac("sha256", master.encode("utf-8"), salt, iterations, dklen=length)
def argon2id_key(master: str, salt: bytes, length: int = 32,
                 t: int = ARGON2_TIME_COST, m: int = ARGON2_MEMORY_COST, p: int = ARGON2_PARALLELISM) -> bytes:
    if not HAS_ARGON2 or _argon_hash_secret is None or _Argon2Type is None:
        raise RuntimeError("Argon2 is not available")
    h = _argon_hash_secret(
        _mix_master_with_pepper(master).encode("utf-8"),
        salt,
        time_cost=int(t),
        memory_cost=int(m),
        parallelism=int(p),
        hash_len=length,
        type=_Argon2Type.ID
    )
    return hashlib.sha256(h).digest()[:length]
def derive_key(master: str, key_salt: bytes,
               prefer_argon: bool = True,
               params: dict | None = None) -> bytes:
    if prefer_argon and HAS_ARGON2:
        p = params or KDF_DEFAULTS
        return argon2id_key(
            master, key_salt, length=32,
            t=int(p.get("t", ARGON2_TIME_COST)),
            m=int(p.get("m", ARGON2_MEMORY_COST)),
            p=int(p.get("p", ARGON2_PARALLELISM)),
        )
    m = _mix_master_with_pepper(master)
    return pbkdf2_key(m, key_salt, length=32)
def make_fernet(master: str, key_salt: bytes,
                *, kdf_name: str = "argon2id",
                params: dict | None = None) -> Fernet:
    key = derive_key(master, key_salt,
                     prefer_argon=(kdf_name == "argon2id"),
                     params=params)
    return Fernet(base64.urlsafe_b64encode(key))
def hash_for_auth(master: str, auth_salt: bytes,
                  prefer_argon: bool = True,
                  params: dict | None = None) -> str:
    if prefer_argon and HAS_ARGON2:
        p = params or KDF_DEFAULTS
        raw = argon2id_key(
            master, auth_salt, length=32,
            t=int(p.get("t", ARGON2_TIME_COST)),
            m=int(p.get("m", ARGON2_MEMORY_COST)),
            p=int(p.get("p", ARGON2_PARALLELISM)),
        )
    else:
        m = _mix_master_with_pepper(master)
        raw = pbkdf2_key(m, auth_salt, length=32)
    return base64.b64encode(raw).decode("utf-8")
def write_auth_file(key_salt: bytes, auth_salt: bytes, verifier_b64: str,
                    kdf_name: str | None = None,
                    kdf_params: dict | None = None):
    rec = {
        "key_salt": base64.b64encode(key_salt).decode("utf-8"),
        "auth_salt": base64.b64encode(auth_salt).decode("utf-8"),
        "verifier": verifier_b64,
        "kdf": kdf_name or ("argon2id" if HAS_ARGON2 else "pbkdf2"),
        "kdf_params": kdf_params or KDF_DEFAULTS,
        "ver": CURRENT_VERSION,
    }
    atomic_write_json(MASTER_FILE, rec)
def is_encrypted(val: str, fernet: Fernet) -> bool:
    if not isinstance(val, str): return False
    try:
        fernet.decrypt(val.encode("utf-8"))
        return True
    except Exception:
        return False
def encrypt_value(val: str, fernet: Fernet) -> str:
    if val is None: val = ""
    if not isinstance(val, str): val = str(val)
    if is_encrypted(val, fernet): return val
    return fernet.encrypt(val.encode("utf-8")).decode("utf-8")
def decrypt_value(val: str, fernet: Fernet) -> str:
    if val is None: return ""
    if not isinstance(val, str): val = str(val)
    try:
        return fernet.decrypt(val.encode("utf-8")).decode("utf-8")
    except Exception:
        return val
def mask_text(_): return "â—" * 8
def atomic_write_json(path: str, obj):
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
        f.flush()
        os.fsync(f.fileno())
    os.replace(tmp, path)
SECURE_JSON_PREFIX = b"LPJS1"
def secure_write_json(path: str, obj, fernet: Fernet) -> None:
    raw = json.dumps(obj, ensure_ascii=False, separators=(",", ":"), sort_keys=False).encode("utf-8")
    enc = fernet.encrypt(raw)
    tmp = path + ".tmp"
    with open(tmp, "wb") as f:
        f.write(SECURE_JSON_PREFIX + enc)
        f.flush()
        os.fsync(f.fileno())
    os.replace(tmp, path)
def secure_read_json(path: str, fernet: Fernet, default):
    if not os.path.exists(path):
        return default
    try:
        with open(path, "rb") as f:
            data = f.read()
        if data.startswith(SECURE_JSON_PREFIX):
            enc = data[len(SECURE_JSON_PREFIX):]
            try:
                raw = fernet.decrypt(enc)
            except InvalidToken as e:
                raise WrongMasterPasswordError("invalid master password") from e
            return json.loads(raw.decode("utf-8"))
        try:
            obj = json.loads(data.decode("utf-8"))
        except Exception:
            with open(path, "r", encoding="utf-8") as fr:
                obj = json.load(fr)
        try:
            secure_write_json(path, obj, fernet)
        except Exception:
            pass
        return obj
    except WrongMasterPasswordError:
        raise
    except InvalidToken as e:
        raise WrongMasterPasswordError("invalid master password") from e
    except Exception:
        return default
def snapshot_now(prefix="blocks"):
    os.makedirs(SNAP_DIR, exist_ok=True)
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    src = BLOCKS_FILE if prefix=="blocks" else TREE_FILE
    dst = os.path.join(SNAP_DIR, f"{prefix}.{ts}.json")
    try:
        if os.path.exists(src): shutil.copy2(src, dst)
    except Exception:
        pass
DOMAIN_LIKE_RE = re.compile(
    r"^(localhost|([a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.)+[a-z]{2,63})(:\d{1,5})?(?:[/?#].*)?$",
    re.IGNORECASE
)
def is_url(s: str) -> bool:
    if not s:
        return False
    s = s.strip()
    sl = s.lower()
    if sl.startswith("http://") or sl.startswith("https://") or "://" in sl:
        return True
    if " " in s:
        return False
    return DOMAIN_LIKE_RE.match(s) is not None
EMAIL_RE = re.compile(r"^[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$")
def is_email_addr(s: str) -> bool:
    if not s: return False
    s = s.strip()
    if " " in s: return False
    return EMAIL_RE.fullmatch(s) is not None
def to_qurl_from_text(s: str) -> QUrl:
    t = (s or "").strip()
    if not t: return QUrl()
    if is_email_addr(t):
        return QUrl("mailto:" + t)
    if "://" not in t:
        t = "https://" + t
    return QUrl(t)
def _lpx_encrypt_bytes(raw: bytes, password: str) -> bytes:
    if not password:
        raise ValueError("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½")
    salt = rand_bytes(16)
    key = argon2id_key(password, salt) if HAS_ARGON2 else pbkdf2_key(password, salt)
    tag = b"A" if HAS_ARGON2 else b"P"
    f = Fernet(base64.urlsafe_b64encode(key))
    enc = f.encrypt(raw)
    return b"LPX1" + tag + salt + enc
def _lpx_decrypt_bytes_or_file(data_or_path: bytes | bytearray | memoryview | str, password: str) -> bytes:
    if isinstance(data_or_path, str):
        with open(data_or_path, "rb") as fr:
            data = fr.read()
    else:
        data = bytes(data_or_path)

    if data.startswith(b"LPX1"):
        off = 4
    elif data.startswith(b"LPEX1"):
        off = 5
    elif data.startswith(b"LPBK1"):
        off = 5
    else:
        raise ValueError("ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ (LPX1/LPEX1/LPBK1)")
    kdf_tag = data[off:off+1]
    salt = data[off+1:off+17]
    enc  = data[off+17:]
    key = argon2id_key(password, salt) if (kdf_tag == b"A" and HAS_ARGON2) else pbkdf2_key(password, salt)
    f = Fernet(base64.urlsafe_b64encode(key))
    return f.decrypt(enc)
ATTACH_CNT_TTL = 2.0
_attach_cnt_cache: dict[str, tuple[float, int]] = {}
def attachments_count(block_id: str) -> int:    
    try:
        import time
        now = time.time()
        rec = _attach_cnt_cache.get(block_id)
        if rec and now - rec[0] < ATTACH_CNT_TTL:
            return rec[1]
        d = os.path.join(ATTACH_DIR, block_id)
        n = 0
        if os.path.isdir(d):
            with os.scandir(d) as it:
                for entry in it:
                    if entry.is_file() and not entry.name.endswith(".meta.json"):
                        n += 1
        _attach_cnt_cache[block_id] = (now, n)
        return n
    except Exception:
        return 0
def attachments_count_invalidate(block_id: str) -> None:
    _attach_cnt_cache.pop(block_id, None)
class WorkerThread(QtCore.QThread):
    ok = Signal(object)
    fail = Signal(str)
    def __init__(self, fn: Callable[[], Any]):
        super().__init__()
        self._fn = fn
    def run(self):
        try:
            res = self._fn()
            self.ok.emit(res)
        except Exception as e:
            self.fail.emit(str(e))
def run_long_task(parent: QWidget, title: str, fn: Callable[[], Any], on_ok: Callable[[Any], None] | None = None):
    dlg = QProgressDialog(title, "ÐžÑ‚Ð¼ÐµÐ½Ð°", 0, 0, parent)
    dlg.setWindowModality(Qt.WindowModality.WindowModal)
    dlg.setMinimumDuration(300)
    th = WorkerThread(fn)
    th.ok.connect(lambda res: (dlg.close(), on_ok(res) if on_ok else None))
    th.fail.connect(lambda msg: (dlg.close(), custom_error(parent, title, msg)))
    th.start()
    dlg.exec()
class IndexDB:
    def __init__(self, path: str, fernet: Fernet, autosave: bool = False):
        self.path = path
        self.fernet = fernet
        self.autosave = autosave
        self._data: dict[str, str] = {}
        class _DummyConn:
            def close(self): pass
        self.conn = _DummyConn()
        self._load()
    def _load(self):
        try:
            if not os.path.exists(self.path):
                self._data = {}
                return
            with open(self.path, "rb") as f:
                head = f.read(16)
            if head.startswith(SECURE_JSON_PREFIX):
                obj = secure_read_json(self.path, self.fernet, {"index": {}})
                self._data = dict(obj.get("index", {})) if isinstance(obj, dict) else {}
                return
            if head.startswith(b"SQLite format 3"):
                try:
                    conn = sqlite3.connect(self.path)
                    c = conn.cursor()
                    try:
                        rows = c.execute("SELECT block_id, text FROM idx").fetchall()
                    except Exception:
                        rows = c.execute("SELECT block_id, text FROM idx_fallback").fetchall()
                    conn.close()
                    self._data = {str(b): str(t) for (b, t) in rows}
                except Exception:
                    self._data = {}
                self.save()
                return
            try:
                with open(self.path, "r", encoding="utf-8") as fr:
                    obj = json.load(fr)
                self._data = dict(obj.get("index", obj)) if isinstance(obj, dict) else {}
                self.save()
            except Exception:
                self._data = {}
        except Exception:
            self._data = {}

    def save(self):
        try:
            secure_write_json(self.path, {"index": self._data}, self.fernet)
        except Exception:
            pass
    def _maybe_save(self):
        if self.autosave:
            self.save()
    def clear(self):
        self._data.clear()
        self._maybe_save()
    def upsert(self, block_id: str, text: str):
        self._data[str(block_id)] = text or ""
        self._maybe_save()
    def delete(self, block_id: str):
        if str(block_id) in self._data:
            del self._data[str(block_id)]
            self._maybe_save()
    def search(self, query: str) -> list[str]:
        q = (query or "").strip().lower()
        if not q:
            return list(self._data.keys())
        return [bid for bid, txt in self._data.items() if q in (txt or "").lower()]
class PasswordDialog(QDialog):
    def __init__(self, title, label, echo_password=True):
        super().__init__()
        self.setWindowTitle(title)
        if os.path.exists(ICON_PATH): self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.edit = QLineEdit()
        self.edit.setEchoMode(QLineEdit.EchoMode.Password if echo_password else QLineEdit.EchoMode.Normal)
        lay = QVBoxLayout(self)
        lay.addWidget(QLabel(label))
        lay.addWidget(self.edit)
        row = QHBoxLayout()
        okb = QPushButton("ÐžÐš"); okb.clicked.connect(self.accept)
        cb = QPushButton("ÐžÑ‚Ð¼ÐµÐ½Ð°"); cb.clicked.connect(self.reject)
        row.addWidget(okb); row.addWidget(cb)
        lay.addLayout(row)
        self.edit.returnPressed.connect(self.accept)
        okb.setCursor(Qt.CursorShape.PointingHandCursor)
        cb.setCursor(Qt.CursorShape.PointingHandCursor)
    def value(self): return self.edit.text()
class MasterPasswordDialog(QDialog):
    def __init__(self, parent=None, first_run: bool = False):
        super().__init__(parent)
        self.setObjectName("MasterPwdDlg")
        self.setWindowTitle("ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.setFixedWidth(420)
        root = QVBoxLayout(self)
        root.setContentsMargins(12, 12, 12, 12)
        root.setSpacing(8)
        hdrv = QVBoxLayout()
        hdrv.setContentsMargins(0, 0, 0, 0)
        hdrv.setSpacing(4)
        ico = QLabel()
        try:
            pm = QPixmap(ICON_PATH)
            if not pm.isNull():
                ico.setPixmap(pm.scaled(36, 36, Qt.AspectRatioMode.KeepAspectRatio,
                                        Qt.TransformationMode.SmoothTransformation))
            else:
                ico.setText("ðŸ”")
                ico.setStyleSheet("font-size:24px;")
        except Exception:
            ico.setText("ðŸ”")
            ico.setStyleSheet("font-size:24px;")
        ico.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        t = QLabel("LinkPass"); t.setObjectName("mp_title")
        t.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        s = QLabel("Ð—Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ" if first_run else "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ"); s.setObjectName("mp_sub")
        s.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        hdrv.addWidget(ico)
        hdrv.addWidget(t)
        hdrv.addWidget(s)
        hdrw = QWidget()
        hdrw.setLayout(hdrv)
        root.addWidget(hdrw, 0, Qt.AlignmentFlag.AlignHCenter)
        input_row = QHBoxLayout()
        input_row.setContentsMargins(0, 0, 0, 0)
        input_row.setSpacing(6)
        self.edit = QLineEdit()
        self.edit.setPlaceholderText("ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ")
        self.edit.setEchoMode(QLineEdit.EchoMode.Password)
        input_row.addWidget(self.edit, 1)
        self.btn_eye = QToolButton()
        self.btn_eye.setCheckable(True)
        self.btn_eye.setText("ðŸ‘")
        self.btn_eye.setToolTip("ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ/ÑÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ")
        self.btn_eye.setFixedSize(28, 26)
        self.btn_eye.toggled.connect(
            lambda on: self.edit.setEchoMode(QLineEdit.EchoMode.Normal if on else QLineEdit.EchoMode.Password)
        )
        input_row.addWidget(self.btn_eye, 0)
        self.btn_paste = QToolButton()
        self.btn_paste.setText("ðŸ“‹")
        self.btn_paste.setToolTip("Ð’ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ð· Ð±ÑƒÑ„ÐµÑ€Ð° Ð¾Ð±Ð¼ÐµÐ½Ð°")
        self.btn_paste.setFixedSize(28, 26)
        self.btn_paste.clicked.connect(lambda: self.edit.setText(QApplication.clipboard().text()))
        input_row.addWidget(self.btn_paste, 0)
        root.addLayout(input_row)
        hint_row = QHBoxLayout()
        hint_row.setContentsMargins(0, 0, 0, 0)
        hint_row.setSpacing(6)
        self.lbl_caps = QLabel("")
        self.lbl_caps.setObjectName("mp_caps")
        hint_row.addWidget(self.lbl_caps, 0, Qt.AlignmentFlag.AlignVCenter)
        hint_row.addStretch(1)
        if first_run:
            lbl_tip = QLabel("Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ â‰¥ 10 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð², Ñ Ñ†Ð¸Ñ„Ñ€Ð°Ð¼Ð¸ Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°Ð¼Ð¸.")
            lbl_tip.setObjectName("mp_tip")
            hint_row.addWidget(lbl_tip, 0, Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        root.addLayout(hint_row)
        self.bar = QProgressBar()
        self.bar.setRange(0, 100)
        self.bar.setTextVisible(False)
        self.bar.setFixedHeight(6)
        self.bar.setVisible(first_run)
        if first_run:
            self.edit.textChanged.connect(self._update_strength)
        root.addWidget(self.bar)
        btn_row = QHBoxLayout()
        btn_row.setContentsMargins(0, 0, 0, 0)
        btn_row.setSpacing(8)
        btn_row.addStretch(1)
        cancel = QPushButton("ÐžÑ‚Ð¼ÐµÐ½Ð°")
        cancel.clicked.connect(self.reject)
        ok = QPushButton("Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ" if first_run else "Ð’Ð¾Ð¹Ñ‚Ð¸")
        ok.setProperty("variant", "primary")
        ok.setDefault(True)
        ok.clicked.connect(self.accept)
        btn_row.addWidget(cancel)
        btn_row.addWidget(ok)
        btn_row.addStretch(1)
        root.addLayout(btn_row)
        self.edit.setFocus()
        self.edit.returnPressed.connect(self.accept)
        for w in (self.btn_eye, self.btn_paste, ok, cancel):
            w.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setStyleSheet("""
        QDialog#MasterPwdDlg { background: #FFFFFF; }
        QLabel#mp_title { font-size: 16px; font-weight: 700; color: #111; }
        QLabel#mp_sub   { font-size: 12px; color: #666; margin-top: 2px; }
        QLabel#mp_caps  { font-size: 11px; color: #b00020; }
        QLabel#mp_tip   { font-size: 11px; color: #555; }
        QLineEdit {
            padding: 6px 8px;
            border: 1px solid #d7d7d7; border-radius: 6px;
            font-size: 14px;
        }
        QLineEdit:focus { border-color: #4979e1; }
        QToolButton {
            border: 1px solid #d7d7d7; border-radius: 6px;
            padding: 0px; background: #f4f4f4;
        }
        QToolButton:hover { background: #eeeeee; }
        QPushButton[variant="primary"] {
            background: #2f6f3a; color: #fff; border: none; border-radius: 6px; padding: 6px 12px;
        }
        QPushButton[variant="primary"]:hover { background: #2b6335; }
        QPushButton {
            background: #f7f7f7; border: 1px solid #e1e1e1; border-radius: 6px; padding: 6px 12px;
        }
        QProgressBar { background: #ececec; border: 1px solid #e3e3e3; border-radius: 3px; }
        QProgressBar::chunk { background: #2f6f3a; border-radius: 3px; }
        """)
        self._caps_timer = QTimer(self)
        self._caps_timer.setInterval(300)
        self._caps_timer.timeout.connect(self._check_caps)
        self._caps_timer.start()
    def _check_caps(self):
        try:
            import ctypes
            on = bool(ctypes.WinDLL("user32").GetKeyState(0x14) & 1)
            self.lbl_caps.setText("Ð’ÐºÐ»ÑŽÑ‡Ñ‘Ð½ CAPS LOCK" if on else "")
        except Exception:
            self.lbl_caps.setText("")
            self._caps_timer.stop()
    def _update_strength(self, s: str):
        score = 0
        L = len(s or "")
        if L >= 8: score += 30
        elif L >= 6: score += 15
        if any(c.islower() for c in s): score += 15
        if any(c.isupper() for c in s): score += 15
        if any(c.isdigit() for c in s): score += 15
        if any(c in "!@#$%^&*()-_=+[]{};:,.?/|\\~`" for c in s): score += 25
        self.bar.setValue(min(100, score))
    def value(self) -> str:
        return self.edit.text()
class CursorFilter(QObject):
    def eventFilter(self, obj, event):
        if isinstance(obj, QPushButton) and event.type() == QEvent.Type.Enter:
            obj.setCursor(Qt.CursorShape.PointingHandCursor)
        return super().eventFilter(obj, event)
class InactivityFilter(QObject):
    activity = Signal()
    def eventFilter(self, obj, event):
        if event.type() in (QEvent.Type.MouseMove, QEvent.Type.KeyPress, QEvent.Type.MouseButtonPress, QEvent.Type.Wheel):
            self.activity.emit()
        return super().eventFilter(obj, event)
class SectionTree(QTreeWidget):
    blockDropped = Signal(str, list)
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.DragDropMode.DropOnly)
        self.setUniformRowHeights(True)
    def dragEnterEvent(self, e):
        if e.mimeData().hasFormat("application/x-linkpass-block-id"): e.acceptProposedAction()
        else: super().dragEnterEvent(e)
    def dragMoveEvent(self, e):
        if e.mimeData().hasFormat("application/x-linkpass-block-id"): e.acceptProposedAction()
        else: super().dragMoveEvent(e)
    def dropEvent(self, e):
        if not e.mimeData().hasFormat("application/x-linkpass-block-id"):
            return super().dropEvent(e)
        item = self.itemAt(e.position().toPoint())
        if not item: return
        path = []
        cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0))
            cur = cur.parent()
        target = "/".join(path)
        data = bytes(e.mimeData().data("application/x-linkpass-block-id")).decode("utf-8")
        ids = [x for x in data.split(",") if x]
        self.blockDropped.emit(target, ids)
        e.acceptProposedAction()
from PySide6.QtWidgets import QLayout, QLayoutItem, QWidgetItem, QWidget, QSizePolicy
from PySide6.QtCore import QRect, QSize, Qt
class GridWrapLayout(QLayout):
    def __init__(self, parent=None, *, margin=8, hSpacing=14, vSpacing=14, card_width=280):
        super().__init__(parent)
        self._items: list[QLayoutItem] = []
        self._h = int(hSpacing)
        self._v = int(vSpacing)
        self._cw = int(card_width)
        self.setContentsMargins(margin, margin, margin, margin)
    def addItem(self, item: QLayoutItem) -> None:
        self._items.append(item)
    def count(self) -> int:
        return len(self._items)
    def itemAt(self, index: int) -> QLayoutItem | None:
        return self._items[index] if 0 <= index < len(self._items) else None
    def takeAt(self, index: int) -> QLayoutItem | None:
        if 0 <= index < len(self._items):
            return self._items.pop(index)
        return None
    def expandingDirections(self):
        return Qt.Orientations(Qt.Orientation(0))
    def hasHeightForWidth(self) -> bool:
        return True
    def heightForWidth(self, width: int) -> int:
        return self._doLayout(QRect(0, 0, width, 0), testOnly=True)
    def setGeometry(self, rect: QRect) -> None:
        super().setGeometry(rect)
        self._doLayout(rect, testOnly=False)
    def sizeHint(self) -> QSize:
        return self.minimumSize()
    def minimumSize(self) -> QSize:
        m = self.contentsMargins()
        w = self._cw + m.left() + m.right()
        h_max = 24
        for it in self._items:
            h_max = max(h_max, it.sizeHint().height())
        h = h_max + m.top() + m.bottom()
        return QSize(w, h)
    def _doLayout(self, rect: QRect, *, testOnly: bool) -> int:
        m = self.contentsMargins()
        eff = rect.adjusted(m.left(), m.top(), -m.right(), -m.bottom())
        if eff.width() <= 0:
            return rect.height()
        ncols = max(1, int((eff.width() + self._h) // (self._cw + self._h)))
        col_x = [eff.x() + i * (self._cw + self._h) for i in range(ncols)]
        rows: list[list[QLayoutItem]] = []
        buf: list[QLayoutItem] = []
        for it in self._items:
            buf.append(it)
            if len(buf) == ncols:
                rows.append(buf); buf = []
        if buf:
            rows.append(buf)
        y = eff.y()
        for row_items in rows:
            row_h = max((it.sizeHint().height() for it in row_items), default=1)
            if not testOnly:
                for c, it in enumerate(row_items):
                    it.setGeometry(QRect(col_x[c], y, self._cw, row_h))
            y += row_h + self._v
        if rows:
            y -= self._v
        return (y - eff.y()) + m.top() + m.bottom()
def default_theme():
    return {
        "window_bg": "#F2F2F2",
        "menubar_bg": "#FFFFFF",
        "menubar_fg": "#202020",
        "menu_bg": "#FFFFFF",
        "menu_fg": "#202020",
        "left_bg": "#FAFAFA",
        "tree_fg": "#202020",
        "kanban_bg": "#FFFFFF",
        "card_bg": "#FFFFFF",
        "block_title_fg": "#101010",
        "field_label_fg": "#333333",
        "field_text_fg": "#000000",
        "tag_bg": "#FFF2B2",
        "attach_badge_bg": "#E7F0FF",
        "attach_badge_fg": "#0F172A",
        "btn_open_bg": "#2f6f3a",
        "btn_bottoms_bg": "#f3f3f3",
        "btn_move_bg": "#0e7490",
        "btn_files_bg": "#4338ca",
        "btn_delete_bg": "#7f1d1d",
        "btn_add_section_bg": "#1d4ed8",
        "btn_add_subsection_bg": "#065f46",
        "btn_delete_section_bg": "#7f1d1d",
        "btn_fg": "#FFFFFF",
        "btn_radius": 10,
    }
def merge_theme(t):
    base = default_theme()
    if t:
        for k, v in t.items(): base[k] = v
    return base
ALPHANUM = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789!@#$%^&*()-_=+[]{};:,.?/|"
class PasswordToolsDialog(QDialog):
    def __init__(self, win):
        super().__init__(win)
        self.win = win
        self.setWindowTitle("ÐŸÐ°Ñ€Ð¾Ð»Ð¸ Ð¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ")
        if os.path.exists(ICON_PATH): self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(700, 520)
        lay = QVBoxLayout(self)
        lay.addWidget(QLabel("<b>Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹</b>"))
        row1 = QHBoxLayout()
        self.combo_enc = QComboBox(); self.combo_enc.addItems(["Base64url", "Hex", "ÐÐ»Ñ„Ð°Ð²Ð¸Ñ‚"])
        row1.addWidget(QLabel("ÐšÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐ°:")); row1.addWidget(self.combo_enc); row1.addStretch(1)
        lay.addLayout(row1)
        self.out_edit = QLineEdit(); self.out_edit.setReadOnly(True)
        lay.addWidget(self.out_edit)
        rowb = QHBoxLayout()
        for bits in (32, 64, 128, 256, 512, 1024, 2048):
            b = QPushButton(f"{bits} Ð±Ð¸Ñ‚")
            b.clicked.connect(lambda _, n=bits: self.generate(n))
            rowb.addWidget(b)
        rowb.addStretch(1)
        lay.addLayout(rowb)
        rowc = QHBoxLayout()
        bc = QPushButton("Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ")
        bc.clicked.connect(lambda: (QApplication.clipboard().setText(self.out_edit.text()), self.win.clip_timer.start(self.win.CLIPBOARD_SEC * 1000)))
        rowc.addWidget(bc); rowc.addStretch(1)
        lay.addLayout(rowc)
        lay.addSpacing(12)
        lay.addWidget(QLabel("<b>Ð¨Ð¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ / Ð”ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ (Fernet)</b>"))
        self.in_edit = QTextEdit(); self.in_edit.setPlaceholderText("Ð¢ÐµÐºÑÑ‚ Ð¸Ð»Ð¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ñ‚ÐµÐºÑÑ‚â€¦")
        lay.addWidget(self.in_edit)
        self.out2 = QTextEdit(); self.out2.setReadOnly(True)
        lay.addWidget(self.out2)
        rowd = QHBoxLayout()
        btn_enc = QPushButton("Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"); btn_enc.clicked.connect(self.do_encrypt)
        btn_dec = QPushButton("Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ"); btn_dec.clicked.connect(self.do_decrypt)
        rowd.addWidget(btn_enc); rowd.addWidget(btn_dec); rowd.addStretch(1)
        lay.addLayout(rowd)
        close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"); close.clicked.connect(self.accept)
        lay.addWidget(close)
    def generate(self, bits: int):
        enc = self.combo_enc.currentText()
        if enc == "Base64url":
            b = rand_bytes(bits // 8)
            s = base64.urlsafe_b64encode(b).decode("utf-8").rstrip("=")
            self.out_edit.setText(s)
        elif enc == "Hex":
            b = rand_bytes(bits // 8)
            self.out_edit.setText(b.hex())
        else:
            alphabet = ALPHANUM
            length = math.ceil(bits / math.log2(len(alphabet)))
            s = "".join(secrets.choice(alphabet) for _ in range(length))
            self.out_edit.setText(s)
    def do_encrypt(self):
        txt = self.in_edit.toPlainText()
        try:
            enc = self.win.fernet.encrypt(txt.encode("utf-8")).decode("utf-8")
            self.out2.setPlainText(enc)
        except Exception as e:
            self.out2.setPlainText(f"[ÐžÑˆÐ¸Ð±ÐºÐ° ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ] {e}")
    def do_decrypt(self):
        txt = self.in_edit.toPlainText()
        try:
            dec = self.win.fernet.decrypt(txt.encode("utf-8")).decode("utf-8")
            self.out2.setPlainText(dec)
        except Exception as e:
            self.out2.setPlainText(f"[ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸] {e}")
class BlockEditorDialog(QDialog):
    def __init__(self, win, block, open_tab: str | None = None):
        super().__init__(win)
        self.win = win
        self.block = block
        self.setWindowTitle(f"Ð‘Ð»Ð¾Ðº: {block.get('title','')}")
        if os.path.exists(ICON_PATH): 
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(820, 700)
        self.tabs = QTabWidget(self)
        main = QWidget()
        self.main_l = QVBoxLayout(main)
        self.main_l.setContentsMargins(8, 8, 8, 8)
        self.LABEL_W = 110
        self._build_title_row()
        self.fields_container = QWidget()
        self.fields_layout = QVBoxLayout(self.fields_container)
        self.fields_layout.setContentsMargins(0, 0, 0, 0)
        self.main_l.addWidget(self.fields_container)
        self.field_edits = {}
        self.rebuild_fields()
        add_row = QHBoxLayout()
        self.new_key = QLineEdit()
        self.new_key.setPlaceholderText("ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð»Ñ")
        btn_add = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»Ðµ")
        btn_add.clicked.connect(self.add_field)
        add_row.addWidget(self.new_key)
        add_row.addWidget(btn_add)
        self.main_l.addLayout(add_row)
        btn_copy = QPushButton("ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²ÑÐµ Ð¿Ð¾Ð»Ñ Ð² Ð±ÑƒÑ„ÐµÑ€")
        btn_copy.clicked.connect(self.copy_all)
        self.main_l.addWidget(btn_copy)
        idx_main = self.tabs.addTab(main, "ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ðµ")
        att = QWidget()
        al = QVBoxLayout(att)
        split = QSplitter(Qt.Orientation.Horizontal)
        left = QWidget()
        ll = QVBoxLayout(left)
        self.lst_att = QListWidget()
        self.lst_att.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        ll.addWidget(self.lst_att)
        row = QHBoxLayout()
        b_add = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»")
        b_add.clicked.connect(self.add_attachment)
        b_save = QPushButton("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÐºÐ°Ðºâ€¦")
        b_save.clicked.connect(self.save_attachment_as)
        b_del = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ")
        b_del.clicked.connect(self.delete_attachment)
        row.addWidget(b_add)
        row.addWidget(b_save)
        row.addWidget(b_del)
        btn_share_files = QPushButton()
        btn_share_files.setProperty("minsize", "compact")
        btn_share_files.setToolTip("ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ñ„Ð°Ð¹Ð»Ð°Ð¼Ð¸")
        share_ico = resource_path("icons/share.png")
        if os.path.exists(share_ico):
            btn_share_files.setIcon(QIcon(share_ico))
            btn_share_files.setIconSize(QtCore.QSize(18, 18))
        else:
            btn_share_files.setText("ðŸ“¤")
        def _share_menu():
            m = QMenu(self)
            a_tg   = QAction(brand_icon("telegram"), "Telegram", self)
            a_wa   = QAction(brand_icon("whatsapp"), "WhatsApp", self)
            a_mail = QAction(brand_icon("mail"),     "Email",    self)
            a_tg.triggered.connect(self._share_files_tg)
            a_wa.triggered.connect(self._share_files_wa)
            a_mail.triggered.connect(self._share_files_email)
            m.addAction(a_tg); m.addAction(a_wa); m.addAction(a_mail)
            m.exec(QCursor.pos())
        btn_share_files.clicked.connect(_share_menu)
        row.addWidget(btn_share_files)
        row.addStretch(1)
        ll.addLayout(row)
        split.addWidget(left)
        right = QWidget()
        rl = QVBoxLayout(right)
        self.preview_stack = QStackedWidget()
        self.preview_img = QLabel("ÐŸÑ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€")
        self.preview_img.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_text = QPlainTextEdit()
        self.preview_text.setReadOnly(True)
        self.preview_blank = QLabel("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð» Ð²Ð¾ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÑ…")
        self.preview_blank.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_stack.addWidget(self.preview_blank)
        self.preview_stack.addWidget(self.preview_img)
        self.preview_stack.addWidget(self.preview_text)
        rl.addWidget(self.preview_stack)
        split.addWidget(right)
        al.addWidget(split)
        self.populate_attachments()
        idx_att = self.tabs.addTab(att, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ")
        idx_notes = self._build_notes_tab()
        self.lst_att.currentItemChanged.connect(lambda *_: self._show_preview())
        raw = QWidget()
        rlay = QVBoxLayout(raw)
        self.raw_edit = QTextEdit()
        self.refresh_json_view()
        rlay.addWidget(self.raw_edit)
        row_json = QHBoxLayout()
        b_apply_json = QPushButton("ÐŸÑ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ JSON")
        b_apply_json.clicked.connect(self.apply_json_changes)
        row_json.addStretch(1)
        row_json.addWidget(b_apply_json)
        rlay.addLayout(row_json)
        idx_json = self.tabs.addTab(raw, "JSON")
        lay = QVBoxLayout(self)
        lay.addWidget(self.tabs)
        btns = QHBoxLayout()
        okb = QPushButton("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ")
        okb.clicked.connect(self.save)
        cb = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
        cb.clicked.connect(self.reject)
        btns.addWidget(okb)
        btns.addWidget(cb)
        lay.addLayout(btns)
        self.idx_main, self.idx_att, self.idx_notes, self.idx_json = idx_main, idx_att, idx_notes, idx_json
        if open_tab == "attachments":
            self.tabs.setCurrentIndex(self.idx_att)
        elif open_tab == "notes":
            self.tabs.setCurrentIndex(self.idx_notes)   
    def refresh_json_view(self):
        self.raw_edit.setPlainText(json.dumps(self.block, ensure_ascii=False, indent=2))
    def _build_title_row(self) -> None:
        self.LABEL_W = getattr(self, "LABEL_W", 110)
        title_row = QHBoxLayout()
        title_row.setSpacing(8)
        title_lab = QLabel("ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ:")
        title_lab.setMinimumWidth(self.LABEL_W)
        title_lab.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        title_lab.setStyleSheet(f"color:{self.win.theme.get('field_label_fg', '#222')};")
        self.title = QLineEdit(self.block.get("title", ""))
        title_lab.setBuddy(self.title)
        title_row.addWidget(title_lab)
        title_row.addWidget(self.title, 1)
        self.main_l.addLayout(title_row)
    def _build_notes_tab(self) -> int:
        notes = QWidget()
        nl = QVBoxLayout(notes)
        self.notes_edit = QPlainTextEdit()
        self.notes_edit.setMaximumBlockCount(0)
        self.notes_edit.setPlaceholderText("Ð¡Ð²Ð¾Ð±Ð¾Ð´Ð½Ñ‹Ðµ Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸ Ð¿Ð¾ Ð±Ð»Ð¾ÐºÑƒâ€¦")
        if self._can_show():
            try:
                self.notes_edit.setPlainText(decrypt_value(self.block.get("notes", ""), self.win.fernet))
            except Exception:
                self.notes_edit.setPlainText("")
            self.notes_edit.setReadOnly(False)
        else:
            self.notes_edit.setPlainText(mask_text(""))
            self.notes_edit.setReadOnly(True)
        nl.addWidget(self.notes_edit)
        return self.tabs.addTab(notes, "Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸")
    def _block_path_list(self) -> list[str]:
        ref = self.win.id_to_ref.get(self.block.get("id",""))
        key = ref[0] if ref else ""
        return [p for p in key.split("/") if p]
    def _can_show(self) -> bool:
        ref = self.win.id_to_ref.get(self.block.get("id", ""))
        key = ref[0] if ref else ""
        path_list = [p for p in key.split("/") if p]
        locked = self.win._locked_prefixes(path_list)
        return all(p in self.win.unlocked_sections for p in locked)
    def commit_edited_fields(self):
        if not self._can_show():
            return
        for k, le in self.field_edits.items():
            self.block["fields"][k] = encrypt_value(le.text(), self.win.fernet)
        try:
            if hasattr(self, "notes_edit"):
                self.block["notes"] = encrypt_value(self.notes_edit.toPlainText(), self.win.fernet)
        except Exception:
            pass
    def rebuild_fields(self):
        def clear_layout(lay: QLayout) -> None:
            while lay.count():
                item = lay.takeAt(0)
                w = item.widget()
                if w is not None:
                    w.deleteLater()
                child = item.layout()
                if child is not None:
                    clear_layout(child)
        clear_layout(self.fields_layout)
        self.field_edits = {}
        def _clean_label(s: str) -> str:
            s = "" if s is None else str(s)
            s = s.replace("\u00A0", " ")
            for ch in ("\u200B","\u200C","\u200D","\u2060","\uFEFF","\u180E","\u202A","\u202B","\u202C","\u202D","\u202E"):
                s = s.replace(ch, "")
            if s.endswith(":"): s = s[:-1].strip()
            return s.strip() or "ÐŸÐ¾Ð»Ðµ"
        for k, v in (self.block.get("fields") or {}).items():
            row = QHBoxLayout()
            lab = QLabel(_clean_label(k) + ":")
            lab.setStyleSheet(f"color:{self.win.theme.get('field_label_fg', '#222')};")
            if hasattr(self, "LABEL_W"):
                lab.setMinimumWidth(self.LABEL_W)
            lab.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            row.addWidget(lab)
            if self._can_show():
                val = decrypt_value(v, self.win.fernet)
                le = QLineEdit(val)
            else:
                le = QLineEdit(mask_text(""))
            le.setReadOnly(not self._can_show())
            le.setStyleSheet(f"color:{self.win.theme.get('field_text_fg', '#000')};")
            row.addWidget(le)
            if self._can_show():
                try_val = decrypt_value(v, self.win.fernet)
                if try_val and (is_url(try_val) or is_email_addr(try_val)):
                    btn_go = QPushButton("â†—")
                    btn_go.setFixedWidth(28); btn_go.setProperty("minsize", "compact")
                    btn_go.clicked.connect(lambda _=False, url=try_val: QDesktopServices.openUrl(to_qurl_from_text(url)))
                    row.addWidget(btn_go)
            btn_del = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»Ðµ")
            btn_del.clicked.connect(lambda _, kk=k: self.delete_field(kk))
            row.addWidget(btn_del)
            self.fields_layout.addLayout(row)
            self.field_edits[k] = le
    def att_dir(self):
        bid = self.block.get("id","")
        d = os.path.join(ATTACH_DIR, bid)
        os.makedirs(d, exist_ok=True)
        return d
    def populate_attachments(self):
        self.lst_att.clear()
        d = self.att_dir()
        for fn in sorted(os.listdir(d)):
            if fn.endswith(".meta.json"): continue
            self.lst_att.addItem(fn)
    def _show_preview(self):
        it = self.lst_att.currentItem()
        if not it:
            self.preview_stack.setCurrentIndex(0)
            return
        fn = it.text()
        src = os.path.join(self.att_dir(), fn)
        try:
            with open(src, "rb") as f:
                enc = f.read()
            data = self.win.fernet.decrypt(enc)
        except Exception:
            self.preview_stack.setCurrentIndex(0)
            return
        pm = QPixmap()
        if pm.loadFromData(data):
            self.preview_img.setPixmap(
                pm.scaled(480, 480, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            )
            self.preview_stack.setCurrentIndex(1)
            return
        if len(data) <= 1_000_000:
            try:
                txt = data.decode("utf-8")
                self.preview_text.setPlainText(txt)
                self.preview_stack.setCurrentIndex(2)
                return
            except Exception:
                pass
        self.preview_stack.setCurrentIndex(0)
    def add_attachment(self):
        path, _ = QFileDialog.getOpenFileName(self, "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»", "", "All Files (*)")
        if not path:
            return
        try:
            with open(path, "rb") as f:
                data = f.read()
            enc = self.win.fernet.encrypt(data)
            base = os.path.basename(path)
            ts   = datetime.now().strftime("%Y%m%d-%H%M%S")
            anon = secrets.token_hex(12)
            out  = os.path.join(self.att_dir(), f"{ts}_{anon}.bin")
            with open(out, "wb") as w:
                w.write(enc)
            meta = {"orig_name": base, "size": len(data), "added": datetime.utcnow().isoformat()+"Z"}
            secure_write_json(out + ".meta.json", meta, self.win.fernet)
            self.populate_attachments()
            attachments_count_invalidate(self.block.get("id", ""))
            self.win.schedule_render()
            audit_write("attachment_add", {"block_id": self.block.get("id",""), "file": os.path.basename(out)})
        except Exception as e:
            QMessageBox.warning(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def save_attachment_as(self):
        it = self.lst_att.currentItem()
        if not it:
            return
        fn = it.text()
        src = os.path.join(self.att_dir(), fn)
        try:
            with open(src, "rb") as f:
                enc = f.read()
            data = self.win.fernet.decrypt(enc)
            suggested = fn.replace(".bin", "")
            mpath = src + ".meta.json"
            if os.path.exists(mpath):
                try:
                    mj = secure_read_json(mpath, self.win.fernet, {})
                    orig = (mj.get("orig_name") or "").strip()
                    if orig:
                        suggested = orig
                except Exception:
                    pass
            save, _ = QFileDialog.getSaveFileName(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÐºÐ°Ðº", suggested)
            if not save:
                return
            with open(save, "wb") as w:
                w.write(data)
            audit_write("attachment_save_as", {"block_id": self.block.get("id",""), "file": fn, "target": save})
        except Exception as e:
            QMessageBox.warning(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def delete_attachment(self):
        it = self.lst_att.currentItem()
        if not it: 
            return
        fn = it.text()
        if not custom_question(self, "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ?", f"Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Â«{fn}Â»?"):
            return
        try:
            d = self.att_dir()
            os.remove(os.path.join(d, fn))
            m = os.path.join(d, fn + ".meta.json")
            if os.path.exists(m):
                os.remove(m)
            self.populate_attachments()
            attachments_count_invalidate(self.block.get("id", ""))
            self.win.schedule_render()
            audit_write("attachment_delete", {"block_id": self.block.get("id",""), "file": fn})
        except Exception as e:
            QMessageBox.warning(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def _export_selected_attachments_for_share(self, open_folder: bool = True) -> list[str]:
        items = self.lst_att.selectedItems()
        if not items:
            QMessageBox.information(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾Ð´Ð¸Ð½ Ð¸Ð»Ð¸ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ„Ð°Ð¹Ð»Ð¾Ð².")
            return []
        out_dir = self.win.make_temp_share_dir(self.block.get("id", "files"))
        saved: list[str] = []
        for it in items:
            fn = it.text()
            src = os.path.join(self.att_dir(), fn)
            try:
                with open(src, "rb") as f:
                    enc = f.read()
                data = self.win.fernet.decrypt(enc)
                meta_name = None
                mpath = src + ".meta.json"
                if os.path.exists(mpath):
                    try:
                        mj = secure_read_json(mpath, self.win.fernet, {})
                        meta_name = (mj.get("orig_name") or "").strip() or None
                    except Exception:
                        pass
                base = meta_name or fn.replace(".bin", "")
                dst = os.path.join(out_dir, base)
                root, ext = os.path.splitext(dst)
                k = 1
                while os.path.exists(dst):
                    dst = f"{root} ({k}){ext}"
                    k += 1
                with open(dst, "wb") as w:
                    w.write(data)
                saved.append(dst)
            except Exception as e:
                QMessageBox.warning(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²Ð¸Ñ‚ÑŒ Â«{fn}Â»: {e}")
        if open_folder:
            try:
                QDesktopServices.openUrl(QUrl.fromLocalFile(out_dir))
            except Exception:
                pass
        return saved
    def _share_files_tg(self) -> None:
        files = self._export_selected_attachments_for_share()
        if files:
            self.win.share_files_telegram(files)
    def _share_files_wa(self) -> None:
        files = self._export_selected_attachments_for_share(open_folder=True)
        if files:
            self.win.share_files_whatsapp(files)
    def _share_files_email(self) -> None:
        files = self._export_selected_attachments_for_share()
        if files:
            self.win.share_files_email(self.block, files)
    def build_share_menu(self) -> QMenu:
        m = QMenu(self)
        a_tg   = QAction(brand_icon("telegram"), "âœˆï¸", self)
        a_wa   = QAction(brand_icon("whatsapp"), "ðŸ’¬", self)
        a_mail = QAction(brand_icon("mail"),     "âœ‰ï¸", self)
        a_tg.setToolTip("ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»Ñ‹ Ð² Telegram")
        a_wa.setToolTip("ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»Ñ‹ Ð² WhatsApp")
        a_mail.setToolTip("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð¸ÑÑŒÐ¼Ð¾ (Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ)")
        a_tg.triggered.connect(self._share_files_tg)
        a_wa.triggered.connect(self._share_files_wa)
        a_mail.triggered.connect(self._share_files_email)
        m.addAction(a_tg); m.addAction(a_wa); m.addAction(a_mail)
        return m
    def add_field(self):
        self.commit_edited_fields()
        self.win.on_block_changed(self.block, meta={"autosave_before_add_field": True})
        k = (self.new_key.text() or "").strip()
        if not k:
            return
        if k in self.block.setdefault("fields", {}):
            return
        self.block["fields"][k] = encrypt_value("", self.win.fernet)
        self.win.on_block_changed(self.block, meta={"add_field": k})
        self.new_key.clear()
        self.rebuild_fields()
        self.refresh_json_view()
    def delete_field(self, key):
        self.commit_edited_fields()
        self.win.on_block_changed(self.block, meta={"autosave_before_delete_field": True})
        if not custom_question(self, "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»Ðµ?", f"ÐŸÐ¾Ð»Ðµ Â«{key}Â» Ð±ÑƒÐ´ÐµÑ‚ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¾ Ð±ÐµÐ·Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚Ð½Ð¾. ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ?"):
            return
        prev = decrypt_value(self.block["fields"][key], self.win.fernet) if self._can_show() else ""
        del self.block["fields"][key]
        self.win.on_block_changed(self.block, meta={"delete_field": key, "prev": prev})

        self.rebuild_fields()
        self.refresh_json_view()

    def copy_all(self):
        title_txt = (self.title.text() if hasattr(self, "title") else self.block.get("title", ""))
        title_txt = (title_txt or "").strip()
        lines = [f"ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ: {title_txt}"] if title_txt else ["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ: (Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)"]

        if not self._can_show():
            path_list = self._block_path_list()
            if not self.win.ensure_chain_unlocked(path_list):
                QApplication.clipboard().setText("\n".join(lines))
                self.win.clip_timer.start(self.win.CLIPBOARD_SEC * 1000)
                return
        for k, v in (self.block.get("fields") or {}).items():
            lines.append(f"{k}: {decrypt_value(v, self.win.fernet)}")
        notes_plain = decrypt_value(self.block.get("notes", ""), self.win.fernet)
        if (notes_plain or "").strip():
            lines.append("Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸:")
            lines.append(notes_plain)
        QApplication.clipboard().setText("\n".join(lines))
        self.win.clip_timer.start(self.win.CLIPBOARD_SEC * 1000)
    def save(self):
        self.commit_edited_fields()
        old = self.block.get("title", "")
        new_title = self.title.text() if hasattr(self, "title") else str(old)
        self.block["title"] = new_title
        self.win.on_block_changed(self.block, meta={"title_from": old, "title_to": new_title})
        self.accept()
    def apply_json_changes(self):
        try:
            j = json.loads(self.raw_edit.toPlainText())
            if not isinstance(j, dict):
                raise ValueError("ÐžÐ¶Ð¸Ð´Ð°ÐµÑ‚ÑÑ JSON-Ð¾Ð±ÑŠÐµÐºÑ‚ Ð±Ð»Ð¾ÐºÐ° (dict).")
            j.setdefault("id", self.block.get("id", secrets.token_hex(12)))
            j.setdefault("title", "")
            j.setdefault("category", self.block.get("category",""))
            j.setdefault("fields", {})
            j.setdefault("notes", "")
            fields = {}
            for k, v in (j.get("fields") or {}).items():
                plain, ok = self.win._try_decrypt_once(v)
                if ok:
                    fields[k] = encrypt_value(plain, self.win.fernet)
                else:
                    fields[k] = encrypt_value(str(v) if v is not None else "", self.win.fernet)
            j["fields"] = fields
            n_plain, okn = self.win._try_decrypt_once(j.get("notes", ""))
            j["notes"] = encrypt_value(n_plain if okn else str(j.get("notes","") or ""), self.win.fernet)
            self.block.clear()
            self.block.update(j)
            self.win.on_block_changed(self.block, meta={"apply_json": True})
            self.rebuild_fields()
            try:
                if hasattr(self, "notes_edit"):
                    self.notes_edit.setPlainText(decrypt_value(self.block.get("notes",""), self.win.fernet))
            except Exception:
                pass
            self.refresh_json_view()
            custom_info(self, "JSON", "Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ñ‹.")
        except Exception as e:
            custom_error(self, "JSON", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
class MainWindow(QMainWindow):
    CLIPBOARD_SEC = 30
    def __init__(self, master_pass: str):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(1340, 880)
        try:
            QLocale.setDefault(QLocale(QLocale.Language.Russian, QLocale.Country.Russia))
        except Exception:
            pass
        self.master = master_pass
        self.key_salt, self.auth_salt = self.ensure_salts()
        self.fernet = make_fernet(self.master, self.key_salt,
                                kdf_name=self.kdf_name, params=self.kdf_params)
        self.meta = self.load_meta()
        self.theme = default_theme()
        self.data_tree = self.load_tree()
        self.blocks_data = self.load_blocks()
        self._temp_share_dirs: set[str] = set()
        self.trash = self.load_trash()
        self.id_to_ref = {}
        self.index = IndexDB(INDEX_DB, self.fernet, autosave=False)
        self.rebuild_index()
        self.current_path: List[str] = []
        self.show_data = False
        self.unlocked_sections: set[str] = set()
        self.search_mode = "Ð‘Ð»Ð¾ÐºÐ¸"
        self._rendering = False
        self.clip_timer = QTimer(self); self.clip_timer.setSingleShot(True)
        self.clip_timer.timeout.connect(lambda: QApplication.clipboard().clear())
        self.scheduler = QTimer(self); self.scheduler.timeout.connect(self.tick_scheduler); self.scheduler.start(60 * 1000)
        self.inact_timer = QTimer(self); self.inact_timer.setSingleShot(True); self.inact_timer.timeout.connect(self.auto_lock)
        self.inact_filter = InactivityFilter(self)
        self.inact_filter.activity.connect(lambda: self.inact_timer.start(int(self.meta.get("autolock_sec", 0) or 0) * 1000) if int(self.meta.get("autolock_sec", 0) or 0) > 0 else None)
        app = QApplication.instance()
        if app is not None:
            self.cursor_filter = CursorFilter(self)
            app.installEventFilter(self.cursor_filter)
            app.installEventFilter(self.inact_filter)
        self._render_timer = QTimer(self); self._render_timer.setSingleShot(True); self._render_timer.timeout.connect(self.render_dashboard)
        self.build_menu()
        self.build_ui()
        self.apply_theme()
        self.render_tree()
        self.schedule_render()
        self.init_tray()
        self.ensure_verifier_current()
        try:
            want = KDF_DEFAULTS
            if (getattr(self, "kdf_name", "argon2id") == "argon2id" and
                (self.kdf_params.get("t") != want["t"] or
                self.kdf_params.get("m") != want["m"] or
                self.kdf_params.get("p") != want["p"])):
                if custom_question(self, "ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ KDF",
                                f"ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Argon2id Ð´Ð¾ t={want['t']}, m={want['m']//1024} MiB, p={want['p']}?"):
                    self.migrate_kdf_params(want, "argon2id")
        except Exception:
            pass
        audit_write("app_start", {"version": CURRENT_VERSION})
    def run_startup_migrations(self) -> None:
        try:
            st = os.path.join(DATA_DIR, "_share_text")
            if os.path.isdir(st):
                for fn in os.listdir(st):
                    if fn.lower().endswith(".txt"):
                        p = os.path.join(st, fn)
                        try:
                            with open(p, "r", encoding="utf-8") as f:
                                txt = f.read()
                            ts = datetime.now().strftime("%Y%m%d-%H%M%S")
                            out = os.path.join(st, f"message_{ts}.json")
                            secure_write_json(out, {"ts": datetime.utcnow().isoformat()+"Z", "text": txt}, self.fernet)
                        except Exception:
                            pass
                        try:
                            os.remove(p)
                        except Exception:
                            pass
        except Exception:
            pass
    def ensure_salts(self):
        if os.path.exists(MASTER_FILE):
            with open(MASTER_FILE, "r", encoding="utf-8") as f:
                j = json.load(f)
            key_salt = base64.b64decode(j["key_salt"])
            auth_salt = base64.b64decode(j["auth_salt"])
            self.kdf_name = j.get("kdf", "argon2id" if HAS_ARGON2 else "pbkdf2")
            self.kdf_params = j.get("kdf_params") or KDF_DEFAULTS
            if "kdf_params" not in j:
                write_auth_file(key_salt, auth_salt, j.get("verifier", ""),
                                self.kdf_name, self.kdf_params)
            return key_salt, auth_salt
        key_salt = rand_bytes(SALT_LEN)
        auth_salt = rand_bytes(SALT_LEN)
        self.kdf_name = "argon2id" if HAS_ARGON2 else "pbkdf2"
        self.kdf_params = KDF_DEFAULTS
        ver = hash_for_auth(self.master, auth_salt,
                            prefer_argon=(self.kdf_name == "argon2id"),
                            params=self.kdf_params)
        write_auth_file(key_salt, auth_salt, ver, self.kdf_name, self.kdf_params)
        return key_salt, auth_salt
    def _locked_prefixes(self, path_list: list[str]) -> list[str]:
        res: list[str] = []
        cur: list[str] = []
        for name in path_list:
            cur.append(name)
            n = self._node_by_path(cur)
            if n and n.get("lock"):
                res.append("/".join(cur))
        return res
    def ensure_chain_unlocked(self, path_list: list[str]) -> bool:
        for i in range(1, len(path_list) + 1):
            pref = path_list[:i]
            key = "/".join(pref)
            n = self._node_by_path(pref)
            if n and n.get("lock") and key not in self.unlocked_sections:
                if not self._verify_section_password(pref):
                    return False
        return True
    def ensure_verifier_current(self):
        try:
            with open(MASTER_FILE, "r", encoding="utf-8") as f:
                j = json.load(f)
            key_salt = base64.b64decode(j["key_salt"])
            auth_salt = base64.b64decode(j["auth_salt"])
            kdf_name = j.get("kdf", getattr(self, "kdf_name", "argon2id" if HAS_ARGON2 else "pbkdf2"))
            kdf_params = j.get("kdf_params") or getattr(self, "kdf_params", KDF_DEFAULTS)
            calc = hash_for_auth(self.master, auth_salt,
                                prefer_argon=(kdf_name == "argon2id"),
                                params=kdf_params)
            init_ver = hash_for_auth("init", auth_salt,
                                    prefer_argon=(kdf_name == "argon2id"),
                                    params=kdf_params)
            if j.get("verifier") in (None, "", init_ver) or "kdf_params" not in j or j.get("kdf") != kdf_name:
                write_auth_file(key_salt, auth_salt, calc, kdf_name, kdf_params)
        except Exception:
            pass
    def verify_master_prompt(self, caption="ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ", label="Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ:") -> bool:
        pwd = self.ask_password(caption, label)
        if pwd is None:
            return False
        try:
            with open(MASTER_FILE, "r", encoding="utf-8") as f:
                j = json.load(f)
            auth_salt = base64.b64decode(j["auth_salt"])
            kdf = j.get("kdf", "argon2id")
            params = j.get("kdf_params") or KDF_DEFAULTS
            calc = hash_for_auth(pwd, auth_salt, prefer_argon=(kdf=="argon2id"), params=params)
            if calc == j.get("verifier"):
                return True
        except Exception:
            pass
        custom_error(self, "ÐžÑˆÐ¸Ð±ÐºÐ°", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.")
        return False
    def load_meta(self):
        meta = {
            "version": CURRENT_VERSION,
            "smart_folders": [],
            "templates": [],
            "export_presets": [],
            "export_tasks": [],
            "autolock_sec": 0,
            "theme": default_theme()
        }
        obj = secure_read_json(META_FILE, self.fernet, meta)
        meta.update(obj if isinstance(obj, dict) else {})
        meta["theme"] = merge_theme(meta.get("theme"))
        meta["version"] = CURRENT_VERSION
        return meta
    def save_meta(self):
        self.meta["theme"] = self.theme
        self.meta["version"] = CURRENT_VERSION
        secure_write_json(META_FILE, self.meta, self.fernet)
    def load_tree(self):
        obj = secure_read_json(TREE_FILE, self.fernet, [])
        return obj if isinstance(obj, list) else []
    def save_tree(self):
        secure_write_json(TREE_FILE, self.data_tree, self.fernet)
    def load_blocks(self):
        blocks = secure_read_json(BLOCKS_FILE, self.fernet, {})
        if not isinstance(blocks, dict):
            blocks = {}
        changed = False
        for key, arr in list(blocks.items()):
            if not isinstance(arr, list):
                continue
            for b in arr:
                if "id" not in b:
                    b["id"] = secrets.token_hex(12); changed = True
                b.setdefault("fields", {})
                n0 = b.get("notes", "")
                plain_notes, okn = self._try_decrypt_once(n0)
                enc_notes = encrypt_value(plain_notes, self.fernet)
                if n0 != enc_notes:
                    b["notes"] = enc_notes
                    changed = True
                want_cat = key.split("/")[-1] if key else ""
                if b.get("category") != want_cat:
                    b["category"] = want_cat
                    changed = True
                for kf, vf in list(b["fields"].items()):
                    plain, ok = self._try_decrypt_once(vf)
                    if ok:
                        enc = encrypt_value(plain, self.fernet)
                        if enc != vf:
                            b["fields"][kf] = enc
                            changed = True
                if "notes" not in b:
                    b["notes"] = ""
                    changed = True
                else:
                    nval = b.get("notes", "")
                    if nval is None:
                        b["notes"] = ""
                        changed = True
                    else:
                        plain, ok = self._try_decrypt_once(nval)
                        if ok:
                            enc = encrypt_value(plain, self.fernet)
                            if enc != nval:
                                b["notes"] = enc
                                changed = True
                        else:
                            if not (isinstance(nval, str) and nval.startswith("gAAAA")):
                                enc = encrypt_value(str(nval), self.fernet)
                                if enc != nval:
                                    b["notes"] = enc
                                    changed = True

        if changed:
            secure_write_json(BLOCKS_FILE, blocks, self.fernet)
        return blocks
    def save_blocks(self):
        secure_write_json(BLOCKS_FILE, self.blocks_data, self.fernet)
    def load_trash(self):
        obj = secure_read_json(TRASH_FILE, self.fernet, [])
        return obj if isinstance(obj, list) else []
    def save_trash(self):
        secure_write_json(TRASH_FILE, self.trash, self.fernet)
    def rebuild_index(self):
        self.index.clear()
        self.id_to_ref.clear()
        for key, arr in self.blocks_data.items():
            for b in arr:
                self.id_to_ref[b["id"]] = (key, b)
                self.update_index_for_block(b)
        try:
            self.index.save()
        except Exception:
            pass
    def update_index_for_block(self, block):
        parts = [block.get("title", ""), block.get("category", "")]
        for k, v in (block.get("fields", {}) or {}).items():
            parts.append(k); parts.append(decrypt_value(v, self.fernet))
        notes_plain = decrypt_value(block.get("notes", ""), self.fernet)
        if notes_plain:
            parts.append(notes_plain)
        txt = "\n".join(parts)
        self.index.upsert(block["id"], txt)
    def remove_index_for_block(self, block):
        self.index.delete(block["id"])
    def _try_decrypt_once(self, v: str) -> tuple[str, bool]:
        if v is None:
            return "", False
        if not isinstance(v, str):
            v = str(v)
        try:
            return self.fernet.decrypt(v.encode("utf-8")).decode("utf-8"), True
        except Exception:
            return v, False
    def build_menu(self):
        mb = self.menuBar()
        filem = mb.addMenu("ðŸ—‚ï¸ Ð¤Ð°Ð¹Ð»")
        a_save = QAction("ðŸ’¾ Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ", self)
        a_save.setShortcut("Ctrl+S")
        a_save.setToolTip("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
        a_save.triggered.connect(self.save_all)
        filem.addAction(a_save)
        filem.addSeparator()
        m_imp = QMenu("ðŸ“¥ Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", self)
        a_imp = QAction("ðŸ“¥ Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ (Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹)", self)
        a_imp.setToolTip("Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð¸Ð· XLSX/CSV/JSON/TXT")
        a_imp.triggered.connect(self.import_data)
        m_imp.addAction(a_imp)
        a_imp_lpx = QAction("ðŸ” Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ (ÑˆÐ¸Ñ„Ñ€.)", self)
        a_imp_lpx.setToolTip("Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°")
        a_imp_lpx.triggered.connect(self.import_paranoid_lpx1)
        m_imp.addAction(a_imp_lpx)
        filem.addMenu(m_imp)
        m_exp = QMenu("ðŸ“¤ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", self)
        a_exp_all = QAction("ðŸ“¤ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ (Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹)", self)
        a_exp_all.setToolTip("Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð² XLSX/CSV/JSON/TXT/HTML")
        a_exp_all.triggered.connect(self.export_all)
        m_exp.addAction(a_exp_all)
        a_exp_lpx = QAction("ðŸ” Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ (ÑˆÐ¸Ñ„Ñ€.)", self)
        a_exp_lpx.setToolTip("Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚")
        a_exp_lpx.triggered.connect(self.export_paranoid_lpx1)
        m_exp.addAction(a_exp_lpx)
        filem.addMenu(m_exp)
        m_bkp = QMenu("ðŸ—„ï¸ Ð‘ÑÐºÐ°Ð¿", self)
        a_bkp = QAction("ðŸ—„ï¸ Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð±ÑÐºÐ°Ð¿ (ÑˆÐ¸Ñ„Ñ€.)", self)
        a_bkp.setToolTip("Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿")
        a_bkp.triggered.connect(self.backup_data_lpx1)
        m_bkp.addAction(a_bkp)
        a_rst = QAction("â™»ï¸ Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°", self)
        a_rst.setToolTip("Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°")
        a_rst.triggered.connect(self.restore_backup_unified)
        m_bkp.addAction(a_rst)
        filem.addMenu(m_bkp)
        filem.addSeparator()
        a_exit = QAction("ðŸšª Ð’Ñ‹Ñ…Ð¾Ð´", self)
        a_exit.setShortcut("Ctrl+Q")
        a_exit.setToolTip("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ")
        from PySide6.QtCore import QCoreApplication
        a_exit.triggered.connect(QCoreApplication.quit)
        filem.addAction(a_exit)
        sett = mb.addMenu("âš™ï¸ ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸")
        a_tools = QAction("ðŸ” ÐŸÐ°Ñ€Ð¾Ð»Ð¸ Ð¸ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ", self)
        a_tools.setToolTip("Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¹, ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ/Ð´ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ")
        a_tools.triggered.connect(self.open_password_tools)
        sett.addAction(a_tools)
        a_pwd = QAction("ðŸ—ï¸ Ð¡Ð¼ÐµÐ½Ð° Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»Ñ", self)
        a_pwd.setToolTip("ÐŸÐµÑ€Ðµâ€‘ÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ° Ð²ÑÐµÑ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð½Ð¾Ð²Ñ‹Ð¼ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÐµÐ¼")
        a_pwd.triggered.connect(self.change_master_password)
        sett.addAction(a_pwd)
        sett.addSeparator()
        a_sf = QAction("ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸", self)
        a_sf.setToolTip("Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑƒÐ¼Ð½Ñ‹Ð¼Ð¸ Ð¿Ð°Ð¿ÐºÐ°Ð¼Ð¸")
        a_sf.triggered.connect(self.manage_smart_folders)
        sett.addAction(a_sf)
        a_tpl = QAction("ðŸ§© Ð¨Ð°Ð±Ð»Ð¾Ð½Ñ‹ Ð±Ð»Ð¾ÐºÐ¾Ð²", self)
        a_tpl.setToolTip("Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°Ð¼Ð¸ Ð¿Ð¾Ð»ÐµÐ¹")
        a_tpl.triggered.connect(self.manage_templates)
        sett.addAction(a_tpl)
        a_prs = QAction("ðŸŽ›ï¸ ÐŸÑ€ÐµÑÐµÑ‚Ñ‹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°", self)
        a_prs.setToolTip("Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ð¿Ñ€ÐµÑÐµÑ‚Ñ‹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°")
        a_prs.triggered.connect(self.manage_export_presets)
        sett.addAction(a_prs)
        a_tasks = QAction("â±ï¸ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð¿Ð¾ Ñ€Ð°ÑÐ¿Ð¸ÑÐ°Ð½Ð¸ÑŽ", self)
        a_tasks.setToolTip("ÐŸÐ»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ñ‰Ð¸Ðº Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ð³Ð¾ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°/Ð±ÑÐºÐ°Ð¿Ð°")
        a_tasks.triggered.connect(self.show_export_tasks)
        sett.addAction(a_tasks)
        binm = mb.addMenu("ðŸ—‘ï¸ ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°")
        a_open_bin = QAction("ðŸ—‘ï¸ ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ", self)
        a_open_bin.setToolTip("ÐŸÑ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ ÑƒÐ´Ð°Ð»Ñ‘Ð½Ð½Ñ‹Ñ… Ð±Ð»Ð¾ÐºÐ¾Ð²")
        a_open_bin.triggered.connect(lambda: RecycleBinDialog(self).exec())
        binm.addAction(a_open_bin)
        a_rest_bin = QAction("â™»ï¸ Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¸Ð· ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñ‹", self)
        a_rest_bin.setToolTip("Ð’ÐµÑ€Ð½ÑƒÑ‚ÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð±Ð»Ð¾Ðº Ð¸Ð· ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñ‹")
        a_rest_bin.triggered.connect(self.restore_from_trash)
        binm.addAction(a_rest_bin)
        a_clear_bin = QAction("ðŸ§¹ ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ", self)
        a_clear_bin.setToolTip("ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ (Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸ÐµÐ¼)")
        a_clear_bin.triggered.connect(self.clear_trash)
        binm.addAction(a_clear_bin)
        binm.addSeparator()
        a_last = QAction("â®ï¸ ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÑƒÐ´Ð°Ð»Ñ‘Ð½Ð½Ñ‹Ð¹", self)
        a_last.setToolTip("ÐŸÐµÑ€ÐµÐ¹Ñ‚Ð¸ Ðº Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¼Ñƒ ÑƒÐ´Ð°Ð»Ñ‘Ð½Ð½Ð¾Ð¼Ñƒ Ð±Ð»Ð¾ÐºÑƒ")
        def _open_last():
            try:
                if not self.trash:
                    custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð° Ð¿ÑƒÑÑ‚Ð°."); return
                last = self.trash[-1].get("block")
                if not last:
                    custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð±Ð»Ð¾ÐºÐ°."); return
                BlockEditorDialog(self, last).exec()
            except Exception as e:
                custom_warning(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ñ: {e}")
        a_last.triggered.connect(_open_last)
        binm.addAction(a_last)
        helpm = mb.addMenu("â“ Ð¡Ð¿Ñ€Ð°Ð²ÐºÐ°")
        a_manual = QAction("ðŸ“– Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ", self)
        a_manual.setToolTip("ÐšÑ€Ð°Ñ‚ÐºÐ¾Ðµ Ñ€ÑƒÐºÐ¾Ð²Ð¾Ð´ÑÑ‚Ð²Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ")
        a_manual.triggered.connect(self.show_manual)
        helpm.addAction(a_manual)
        a_license = QAction("ðŸ§¾ Ð›Ð¸Ñ†ÐµÐ½Ð·Ð¸Ñ", self)
        a_license.setToolTip("ÐŸÑ€Ð°Ð²Ð¾Ð²Ñ‹Ðµ ÑÐ²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¸ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸")
        a_license.triggered.connect(self.show_license)
        helpm.addAction(a_license)
        a_about = QAction("â„¹ï¸ Ðž Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ðµ", self)
        a_about.setToolTip("Ð¡Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¾ Ð²ÐµÑ€ÑÐ¸Ð¸ Ð¸ Ð°Ð²Ñ‚Ð¾Ñ€Ðµ")
        a_about.triggered.connect(lambda: custom_info(self, "Ðž Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ðµ", PROGRAM_INFO))
        helpm.addAction(a_about)
        a_donate = QAction("ðŸ’– ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚", self)
        a_donate.setToolTip("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ð´Ð¾Ð½Ð°Ñ‚Ð° (YooMoney)")
        a_donate.triggered.connect(lambda: self.open_url_safe(QUrl("https://yoomoney.ru/to/410011663886937"), "ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚"))
        helpm.addAction(a_donate)
    from typing import Optional, cast
    def _b64url_pad(self, s: str) -> str:
        if not s:
            return ""
        return s + "=" * (-len(s) % 4)
    def _dec_paranoid_token(self, s: str) -> str:
        try:
            raw = base64.urlsafe_b64decode(self._b64url_pad(s))
            dec = self.fernet.decrypt(raw)
            return dec.decode("utf-8")
        except Exception as e:
            try:
                dec = self.fernet.decrypt((s or "").encode("utf-8"))
                return dec.decode("utf-8")
            except Exception:
                raise
    def import_paranoid_lpx1(self) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ (LPX1, Ð¿Ð°Ñ€Ð°Ð½Ð¾Ð¸Ð´Ð°Ð»ÑŒÐ½Ñ‹Ð¹)", "",
            "LPX1 (*.lpx);;Ð’ÑÐµ Ñ„Ð°Ð¹Ð»Ñ‹ (*.*)"
        )
        if not path:
            return
        pwd = self.ask_password("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ñ„Ð°Ð¹Ð»Ð°", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ðº .lpx:")
        if pwd is None:
            return
        try:
            data = _lpx_decrypt_bytes_or_file(path, pwd)
            try:
                payload = json.loads(data.decode("utf-8"))
            except Exception as e:
                raise ValueError(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°Ð·Ð¾Ð±Ñ€Ð°Ñ‚ÑŒ JSON Ð¸Ð· Ñ„Ð°Ð¹Ð»Ð°: {e}")
            if not isinstance(payload, dict) or "items" not in payload or not isinstance(payload["items"], list):
                raise ValueError("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ ÑÐ¿Ð¸ÑÐ¾Ðº 'items'.")
            items = payload.get("items", [])
            if not items:
                custom_info(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "Ð’ Ñ„Ð°Ð¹Ð»Ðµ Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…."); 
                return
            imported = 0
            created_paths: set[str] = set()
            for it in items:
                try:
                    k_enc = it.get("k", "")
                    t_enc = it.get("t", "")
                    f_list = it.get("f", [])
                    key = self._dec_paranoid_token(k_enc)
                    title = self._dec_paranoid_token(t_enc)
                    fields: dict[str, str] = {}
                    for pair in f_list or []:
                        if not isinstance(pair, list) or len(pair) != 2:
                            continue
                        name = self._dec_paranoid_token(pair[0])
                        value_plain = self._dec_paranoid_token(pair[1])
                        fields[name] = encrypt_value(value_plain, self.fernet)
                    if key:
                        self._ensure_tree_path(key)
                        created_paths.add(key)
                    block = {
                        "id": secrets.token_hex(12),
                        "title": title or "",
                        "category": key.split("/")[-1] if key else "",
                        "fields": fields,
                        "icon": ""
                    }
                    self.blocks_data.setdefault(key, []).append(block)
                    self.id_to_ref[block["id"]] = (key, block)
                    self.update_index_for_block(block)
                    imported += 1
                except InvalidToken:
                    raise RuntimeError(
                        "Ð¤Ð°Ð¹Ð» Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½, Ð½Ð¾ Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð´Ñ€ÑƒÐ³Ð¸Ð¼ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘ÐºÐ»ÑŽÑ‡Ð¾Ð¼.\n"
                        "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð²Ð¾Ð·Ð¼Ð¾Ð¶ÐµÐ½ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ñ‚Ð¾Ð¹ Ð¶Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐµ Ñ Ñ‚ÐµÐ¼ Ð¶Ðµ master/auth.json, "
                        "Ñ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¼ Ð´ÐµÐ»Ð°Ð»ÑÑ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚."
                    )
            if created_paths:
                self.save_tree()
                self.render_tree()
            self.save_blocks()
            self.schedule_render()
            custom_info(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", f"Ð“Ð¾Ñ‚Ð¾Ð²Ð¾. Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð±Ð»Ð¾ÐºÐ¾Ð²: {imported}.")
            audit_write("import_paranoid_lpx1", {
                "file": path,
                "items": imported,
                "sections_touched": len(created_paths)
            })
        except InvalidToken:
            custom_error(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ðº LPX1 Ñ„Ð°Ð¹Ð»Ñƒ.")
        except RuntimeError as e:
            custom_error(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", str(e))
        except Exception as e:
            custom_error(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def apply_theme(self):
        try:
            t = self.theme = merge_theme(self.theme)
            r = int(t.get("btn_radius", 10))
            fg = t.get("btn_fg", "#FFFFFF")
            app_core = QCoreApplication.instance()
            if isinstance(app_core, QApplication):
                app_core.setStyleSheet(f"""
                    QMainWindow {{ background: {t['window_bg']}; }}
                    QMenuBar {{ background: {t['menubar_bg']}; color: {t['menubar_fg']}; }}
                    QMenuBar::item {{ background: transparent; color: {t['menubar_fg']}; padding:4px 10px; border-radius:{r}px; }}
                    QMenuBar::item:selected {{ background: rgba(0,0,0,0.08); }}
                    QMenu {{ background: {t['menu_bg']}; color: {t['menu_fg']}; }}
                    QMenu::item {{ padding:5px 12px; border-radius:{r}px; }}
                    QMenu::item:selected {{ background: rgba(0,0,0,0.08); }}
                    QWidget#leftPane {{ background: {t['left_bg']}; }}
                    QTreeWidget {{ background: {t['left_bg']}; color: {t['tree_fg']}; font-size:14px; }}
                    QTreeWidget::item {{ height:25px; }}
                    QScrollArea#kanbanScroll, QScrollArea#kanbanScroll > QWidget#qt_scrollarea_viewport {{ background: {t['kanban_bg']}; }}
                    QWidget#rightPane {{ background: {t['kanban_bg']}; }}
                    QPushButton {{
                        background: #F5F5F5;
                        color: #111;
                        border: 1px solid rgba(0,0,0,0.08);
                        border-radius: {r}px;
                        padding: 6px 12px;
                    }}
                    QPushButton:hover {{ background: #F0F0F0; }}
                    QPushButton:pressed {{ background: #E9E9E9; }}
                    QPushButton:disabled {{ color: #888; background: #F9F9F9; }}
                    QPushButton[minsize="compact"] {{
                        padding: 2px 6px;
                        min-width: 24px;
                        max-height: 24px;
                        border-radius: {int(r*0.7)}px;
                    }}

                    QFrame#BlockCard {{
                        background: {t['card_bg']};
                        border: 1px solid rgba(17, 24, 39, 0.06);
                        border-radius: 14px;
                    }}
                    QFrame#BlockCard:hover {{
                        border: 1px solid rgba(17, 24, 39, 0.12);
                        background: #FFFFFF;
                    }}

                """)
            if hasattr(self, "btn_add_section"):
                self.btn_add_section.setStyleSheet(f"background:{t['btn_add_section_bg']};color:{fg};border:none;border-radius:{r}px;")
            if hasattr(self, "btn_add_subsection"):
                self.btn_add_subsection.setStyleSheet(f"background:{t['btn_add_subsection_bg']};color:{fg};border:none;border-radius:{r}px;")
            if hasattr(self, "btn_del_section"):
                self.btn_del_section.setStyleSheet(f"background:{t['btn_delete_section_bg']};color:{fg};border:none;border-radius:{r}px;")
            self.render_dashboard()
        except Exception as e:
            custom_warning(self, "Ð¢ÐµÐ¼Ð°", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ: {e}")
    def reset_theme(self):
        self.theme = default_theme()
        self.meta["theme"] = self.theme
        self.save_meta()
        self.apply_theme()
    def build_ui(self):
        central = QWidget(self); central.setObjectName("central")
        self.setCentralWidget(central)
        lay = QHBoxLayout(central); lay.setContentsMargins(8, 8, 8, 8)
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        lay.addWidget(self.splitter)
        left = QWidget(); left.setObjectName("leftPane")
        ll = QVBoxLayout(left); ll.setContentsMargins(6,6,6,6)
        self.tree = SectionTree(self)
        hdr = self.tree.header()
        hdr.setStretchLastSection(False)
        hdr.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        self.tree.setColumnWidth(0, 220)
        self.tree.setHeaderLabel("Ð Ð°Ð·Ð´ÐµÐ»Ñ‹")
        self.tree.blockDropped.connect(self.on_blocks_dropped_to_section)
        self.tree.itemClicked.connect(self.on_tree_item_clicked)
        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.tree_context_menu)
        ll.addWidget(self.tree)
        row = QHBoxLayout()
        self.btn_add_section = QPushButton("+ Ð Ð°Ð·Ð´ÐµÐ»"); self.btn_add_section.clicked.connect(self.create_item)
        self.btn_add_subsection = QPushButton("+ ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»"); self.btn_add_subsection.clicked.connect(self.create_subsection_by_sel)
        self.btn_del_section = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"); self.btn_del_section.clicked.connect(self.delete_item_by_sel)
        row.addWidget(self.btn_add_section); row.addWidget(self.btn_add_subsection); row.addWidget(self.btn_del_section)
        ll.addLayout(row)
        self.splitter.addWidget(left)
        right = QWidget(); right.setObjectName("rightPane")
        rl = QVBoxLayout(right); rl.setContentsMargins(6,6,6,6)
        srow = QHBoxLayout()
        self.search_input = QLineEdit(); self.search_input.setPlaceholderText("ÐŸÐ¾Ð¸ÑÐºâ€¦")
        self.search_timer = QTimer(self); self.search_timer.setSingleShot(True); self.search_timer.setInterval(SEARCH_DEBOUNCE_MS)
        self.search_input.textChanged.connect(lambda _=None: self.search_timer.start())
        self.search_timer.timeout.connect(self.render_dashboard)
        self.filter_box = QComboBox(); self.filter_box.addItems(["Ð‘Ð»Ð¾ÐºÐ¸","ÐŸÐ¾Ð»Ñ"])
        self.filter_box.currentIndexChanged.connect(lambda _: self.set_search_mode(self.filter_box.currentText()))
        srow.addWidget(QLabel("ðŸ”")); srow.addWidget(self.search_input); srow.addWidget(self.filter_box)
        self.btn_clear = QPushButton("âœ–"); self.btn_clear.setFixedWidth(28); self.btn_clear.setProperty("minsize","compact")
        self.btn_clear.clicked.connect(lambda: self.search_input.setText(""))
        srow.addWidget(self.btn_clear)
        btn_sf = QPushButton("Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸"); btn_sf.clicked.connect(self.manage_smart_folders)
        btn_tpl = QPushButton("Ð¨Ð°Ð±Ð»Ð¾Ð½Ñ‹"); btn_tpl.clicked.connect(self.manage_templates)
        btn_prs = QPushButton("ÐŸÑ€ÐµÑÐµÑ‚Ñ‹"); btn_prs.clicked.connect(self.manage_export_presets)
        srow.addWidget(btn_sf); srow.addWidget(btn_tpl); srow.addWidget(btn_prs)
        self.btn_att_only = QPushButton("ðŸ“Ž"); self.btn_att_only.setCheckable(True); self.btn_att_only.setProperty("minsize","compact")
        self.btn_att_only.setToolTip("ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð±Ð»Ð¾ÐºÐ¸ Ñ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÐ¼Ð¸")
        self.btn_att_only.clicked.connect(self.render_dashboard)
        srow.addWidget(self.btn_att_only)
        self.btn_add_block = QPushButton("+ Ð‘Ð»Ð¾Ðº"); self.btn_add_block.clicked.connect(self.add_block)
        srow.addWidget(self.btn_add_block)
        self.btn_toggle_data = QPushButton("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
        self.btn_toggle_data.setCheckable(True); self.btn_toggle_data.setChecked(False)
        self.btn_toggle_data.clicked.connect(self.toggle_data)
        srow.addWidget(self.btn_toggle_data)
        rl.addLayout(srow)
        self.kanban_area = QScrollArea(); self.kanban_area.setObjectName("kanbanScroll")
        self.kanban_area.setWidgetResizable(True)
        self.kanban_content = QWidget()
        self.kanban_layout = GridWrapLayout(self.kanban_content, margin=8, hSpacing=14, vSpacing=14, card_width=300)
        self.kanban_content.setLayout(self.kanban_layout)
        self.kanban_content.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Preferred)
        self.kanban_area.setWidget(self.kanban_content)
        self.kanban_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.kanban_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        right.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.kanban_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        rl.addWidget(self.kanban_area)
        self.splitter.addWidget(right)
        self.splitter.setSizes([330, 1050])
        self.splitter.setChildrenCollapsible(False)
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        left.setMinimumWidth(300)
        act = QAction(self); act.setShortcut("Ctrl+R"); act.triggered.connect(self.create_item); self.addAction(act)
        act2= QAction(self); act2.setShortcut("Ctrl+P"); act2.triggered.connect(self.create_subsection_by_sel); self.addAction(act2)
        act3= QAction(self); act3.setShortcut("Ctrl+B"); act3.triggered.connect(self.add_block); self.addAction(act3)
        act4= QAction(self); act4.setShortcut("Ctrl+S"); act4.triggered.connect(lambda: self.search_input.setFocus()); self.addAction(act4)
        act_up = QAction(self); act_up.setShortcut("Alt+Up")
        act_up.triggered.connect(lambda: self.move_item_up(self.tree.currentItem()))
        self.addAction(act_up)
        act_dn = QAction(self); act_dn.setShortcut("Alt+Down")
        act_dn.triggered.connect(lambda: self.move_item_down(self.tree.currentItem()))
        self.addAction(act_dn)
    def init_tray(self):
        if not QSystemTrayIcon.isSystemTrayAvailable():
            return
        self.tray = QSystemTrayIcon(self.windowIcon(), self)
        menu = QMenu()
        a_show = QAction("ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ", self);    a_show.triggered.connect(self.showNormal)
        a_lock = QAction("Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", self); a_lock.triggered.connect(self.auto_lock)
        a_exit = QAction("Ð’Ñ‹Ñ…Ð¾Ð´", self);       a_exit.triggered.connect(self.close)
        menu.addAction(a_show)
        menu.addAction(a_lock)
        menu.addSeparator()
        menu.addAction(a_exit)
        self.tray.setContextMenu(menu)
        self.tray.setToolTip(APP_TITLE)
        self.tray.show()
    def schedule_temp_cleanup(self, path: str, after_sec: int = SHARE_TEMP_TTL_SEC, is_dir: bool | None = None) -> None:
        if is_dir is None:
            is_dir = os.path.isdir(path)
        def _cleanup():
            try:
                if is_dir and os.path.isdir(path):
                    shutil.rmtree(path, ignore_errors=True)
                elif os.path.isfile(path):
                    try: os.remove(path)
                    except Exception: pass
            finally:
                try:
                    self._temp_share_dirs.discard(path)
                except Exception:
                    pass
        QtCore.QTimer.singleShot(max(5, int(after_sec)) * 1000, _cleanup)
    def make_temp_share_dir(self, tag: str = "share") -> str:
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        d = tempfile.mkdtemp(prefix=f"LinkPass_{tag}_{ts}_")
        self._temp_share_dirs.add(d)
        self.schedule_temp_cleanup(d, SHARE_TEMP_TTL_SEC, is_dir=True)
        return d
    def write_temp_text_for_send(self, text: str) -> str:
        out_dir = self.make_temp_share_dir("text")
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        path = os.path.join(out_dir, f"message_{ts}.txt")
        with open(path, "w", encoding="utf-8") as f:
            f.write((text or "").replace("\r\n", "\n"))
        return path
    def archive_share_text_encrypted(self, text: str) -> str:
        return ""
    def open_password_tools(self):
        PasswordToolsDialog(self).exec()
    def show_text_dialog(self, title: str, text: str) -> None:
        dlg = QDialog(self)
        dlg.setWindowTitle(title)
        if os.path.exists(ICON_PATH):
            dlg.setWindowIcon(QIcon(ICON_PATH))
        dlg.resize(780, 620)
        lay = QVBoxLayout(dlg)
        ed = QPlainTextEdit()
        ed.setReadOnly(True)
        ed.setPlainText(text)
        lay.addWidget(ed)
        bb = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        bb.rejected.connect(dlg.reject)
        bb.accepted.connect(dlg.accept)
        lay.addWidget(bb)
        dlg.exec()
    def show_manual(self) -> None:
        self.show_text_dialog("Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ", MANUAL_TEXT)
    def show_license(self) -> None:
        self.show_text_dialog("Ð›Ð¸Ñ†ÐµÐ½Ð·Ð¸Ñ", LICENSE_TEXT)
    def ask_password(self, title, label, echo_password=True):
        dlg = PasswordDialog(title, label, echo_password=echo_password)
        return dlg.value() if dlg.exec() == QDialog.DialogCode.Accepted else None
    def schedule_render(self):
        self._render_timer.start(TREE_RENDER_DELAY_MS)
    def set_search_mode(self, m):
        self.search_mode = m
        self.render_dashboard()
    def current_key(self): return "/".join(self.current_path)
    def get_section_color(self, path):
        node = None; nodes = self.data_tree
        for name in path:
            node = next((n for n in nodes if n["name"] == name), None)
            if node: nodes = node.get("children", [])
            else: break
        return node.get("color", self.theme.get("tag_bg", "#f4e4ae")) if node else self.theme.get("tag_bg", "#f4e4ae")
    def get_all_paths(self):
        out=[]
        def rec(nodes, pref):
            for n in nodes:
                p = pref + [n["name"]]
                out.append("/".join(p))
                rec(n.get("children",[]), p)
        rec(self.data_tree, [])
        return out
    def _ensure_tree_path(self, section_path):
        if not section_path: return
        parts = section_path.split("/")
        nodes = self.data_tree
        for name in parts:
            found = next((n for n in nodes if n["name"] == name), None)
            if not found:
                found = {"name": name, "children": [], "color": self.theme.get("tag_bg","#f4e4ae")}
                nodes.append(found)
            nodes = found["children"]
    def find_node(self, path_list):
        nodes = self.data_tree; parent = None
        for name in path_list:
            parent = next((n for n in nodes if n["name"] == name), None)
            if not parent: return None, None
            nodes = parent.get("children", [])
        return parent, nodes
    def find_parent_and_index(self, path_list):
        if not path_list: return None, None, -1
        nodes = self.data_tree
        parent = None
        for i, name in enumerate(path_list):
            prev_nodes = nodes
            node = next((n for n in nodes if n["name"] == name), None)
            if node is None: return None, None, -1
            if i == len(path_list)-1:
                return prev_nodes, node, prev_nodes.index(node)
            nodes = node.get("children", [])
        return None, None, -1
    from typing import List, Optional, Tuple
    def _item_path(self, item: Optional[QTreeWidgetItem]) -> List[str]:
        path: List[str] = []
        cur = item
        while cur is not None and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0))
            cur = cur.parent()
        return path
    def _find_item_by_path(self, path_list: List[str]) -> Optional[QTreeWidgetItem]:
        if not path_list:
            return None
        for i in range(self.tree.topLevelItemCount()):
            it = self.tree.topLevelItem(i)
            if it is None:
                continue
            if it.text(0) == "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
                continue
            if it.text(0) == path_list[0]:
                cur = it
                for name in path_list[1:]:
                    found: Optional[QTreeWidgetItem] = None
                    for j in range(cur.childCount()):
                        ch = cur.child(j)
                        if ch is not None and ch.text(0) == name:
                            found = ch
                            break
                    if found is None:
                        return None
                    cur = found
                return cur
        return None
    def _select_path_in_tree(self, path_list: List[str]) -> None:
        it = self._find_item_by_path(path_list)
        if it is not None:
            self.tree.setCurrentItem(it)
    def _reorder_section(self, path_list, direction: int):
        parent_list, node, idx = self.find_parent_and_index(path_list)
        if node is None or parent_list is None or idx < 0:
            return
        new_idx = idx + direction
        if new_idx < 0 or new_idx >= len(parent_list):
            return
        parent_list.pop(idx)
        parent_list.insert(new_idx, node)
        self.save_tree()
        self.render_tree()
        self._select_path_in_tree(path_list)
        self.schedule_render()
        audit_write("section_reorder", {
            "path": "/".join(path_list),
            "direction": "up" if direction < 0 else "down",
            "new_index": new_idx
        })
    def move_item_up(self, item):
        path = self._item_path(item)
        if path:
            self._reorder_section(path, -1)
    def move_item_down(self, item):
        path = self._item_path(item)
        if path:
            self._reorder_section(path, +1)
    def _apply_tree_item_colors(self):
        col = QColor(self.theme.get("tree_fg", "#202020"))
        def rec(it):
            it.setForeground(0, col)
            for i in range(it.childCount()):
                rec(it.child(i))
        for i in range(self.tree.topLevelItemCount()):
            rec(self.tree.topLevelItem(i))
    def render_tree(self) -> None:
        self.tree.clear()
        def norm_name(x: object) -> str:
            s = "" if x is None else str(x)
            s = s.replace("\ufeff", "").strip()
            return s if s else "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)"
        def add_items(parent: QTreeWidgetItem, nodes: List[dict], prefix_path: List[str]) -> None:
            for n in nodes:
                n["name"] = norm_name(n.get("name", ""))
                n.setdefault("children", [])
                n.setdefault("color", self.theme.get("tag_bg", "#f4e4ae"))
                it = QTreeWidgetItem([n["name"]])
                it.setIcon(0, self._color_icon(n.get("color", self.theme.get("tag_bg", "#f4e4ae"))))
                it.setData(0, Qt.ItemDataRole.UserRole, ("section", "/".join(prefix_path + [n["name"]])))
                parent.addChild(it)
                add_items(it, n.get("children", []), prefix_path + [n["name"]])
        if self.meta.get("smart_folders"):
            root_sf = QTreeWidgetItem(["ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸"])
            self.tree.addTopLevelItem(root_sf)
            for sf in self.meta["smart_folders"]:
                it = QTreeWidgetItem([norm_name(sf.get("name", ""))])
                it.setData(0, Qt.ItemDataRole.UserRole, ("smart", sf))
                root_sf.addChild(it)
        for top in self.data_tree:
            top["name"] = norm_name(top.get("name", ""))
            top.setdefault("color", self.theme.get("tag_bg", "#f4e4ae"))
            it = QTreeWidgetItem([top["name"]])
            it.setIcon(0, self._color_icon(top["color"]))
            it.setData(0, Qt.ItemDataRole.UserRole, ("section", top["name"]))
            self.tree.addTopLevelItem(it)
            add_items(it, top.get("children", []), [top["name"]])
        try:
            self.tree.itemClicked.disconnect(self.on_tree_item_clicked)
        except Exception:
            pass
        self.tree.itemClicked.connect(self.on_tree_item_clicked)

        if DEFAULT_EXPAND_DEPTH < 0:
            self.tree.collapseAll()
        else:
            self.tree.expandToDepth(DEFAULT_EXPAND_DEPTH)
        col = QColor(self.theme.get("tree_fg", "#202020"))
        def rec_color(it: Optional[QTreeWidgetItem]):
            if it is None:
                return
            it.setForeground(0, col)
            for i in range(it.childCount()):
                rec_color(it.child(i))
        for i in range(self.tree.topLevelItemCount()):
            rec_color(self.tree.topLevelItem(i))
    def _contrast_text_for(self, bg: str) -> str:
        c = QColor(bg)
        if not c.isValid():
            c = QColor(self.theme.get("tag_bg", "#f4e4ae"))
        yiq = (299 * c.red() + 587 * c.green() + 114 * c.blue()) / 1000.0
        return "#FFFFFF" if yiq < 140 else "#000000"
    def _color_icon(self, color: str, size: int = 14, radius: int = 3) -> QIcon:
        pm = QPixmap(size, size)
        pm.fill(Qt.GlobalColor.transparent)
        qc = QColor(color)
        if not qc.isValid():
            qc = QColor(self.theme.get("tag_bg", "#f4e4ae"))
        p = QPainter(pm)
        p.setRenderHint(QPainter.RenderHint.Antialiasing, True)
        p.setPen(QPen(QColor(0, 0, 0, 60), 1))
        p.setBrush(qc)
        rect = pm.rect().adjusted(1, 1, -1, -1)
        p.drawRoundedRect(rect, radius, radius)
        p.end()
        return QIcon(pm)
    def on_tree_item_clicked(self, item: Optional[QTreeWidgetItem], _col: int) -> None:
        if item is None:
            return
        kind = item.data(0, Qt.ItemDataRole.UserRole)
        if isinstance(kind, tuple) and len(kind) > 0 and kind[0] == "smart":
            sf = kind[1] if len(kind) > 1 else {}
            name = sf.get("name", "") if isinstance(sf, dict) else ""
            self.current_path = ["__SMART__", name]
            self.schedule_render()
            return
        path: List[str] = []
        cur = item
        while cur is not None and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0))
            cur = cur.parent()
        self.current_path = path
        self.schedule_render()
    def tree_context_menu(self, pos: QtCore.QPoint) -> None:
        item = self.tree.itemAt(pos)
        menu = QMenu()
        def _add_action(text: str, slot, png: str | None = None) -> QAction:
            act = QAction(text, self)
            if png:
                p = resource_path(f"icons/{png}")
                if os.path.exists(p):
                    act.setIcon(QIcon(p))
            act.triggered.connect(slot)
            menu.addAction(act)
            return act
        if item is None:
            _add_action("âž• Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»", self.create_item, "add.png")
            menu.exec(self.tree.viewport().mapToGlobal(pos))
            return
        kind = item.data(0, Qt.ItemDataRole.UserRole)
        if isinstance(kind, tuple) and len(kind) > 0 and kind[0] == "smart":
            _add_action("ðŸ“‚ ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹", lambda: self.on_tree_item_clicked(item, 0), "open.png")
            menu.addSeparator()
            _add_action("ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸â€¦", self.manage_smart_folders, "smart.png")
            menu.exec(self.tree.viewport().mapToGlobal(pos))
            return
        _add_action("âž• Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", lambda: self.create_subitem(item), "add.png")
        _add_action("âœï¸ ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ñ‚ÑŒ",     lambda: self.rename_item(item), "rename.png")
        _add_action("ðŸ—‘ï¸ Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ",           lambda: self.delete_item(item), "delete.png")
        menu.addSeparator()
        _add_action("â¬†ï¸ Ð’Ð²ÐµÑ€Ñ…",              lambda: self.move_item_up(item), "arrow_up.png")
        _add_action("â¬‡ï¸ Ð’Ð½Ð¸Ð·",               lambda: self.move_item_down(item), "arrow_down.png")
        menu.addSeparator()
        _add_action("ðŸŽ¨ Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ†Ð²ÐµÑ‚",       lambda: self.set_section_color(item), "color.png")
        path_list = self._path_from_item(item)
        if self.is_path_locked(path_list):
            _add_action("ðŸ”“ Ð¡Ð½ÑÑ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ",   lambda: self._menu_clear_lock(item), "unlock.png")
        else:
            _add_action("ðŸ”’ Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ", lambda: self._menu_set_lock(item), "lock.png")
        menu.addSeparator()
        _add_action("ðŸ“¤ Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»â€¦", lambda: self.export_section(item), "export.png")
        _add_action("ðŸ“¦ ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»â€¦",    lambda: self.move_section_by_menu(item), "move.png")
        share_menu = menu.addMenu("ðŸ“¤ ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑâ€¦")
        p_tg = resource_path("icons/telegram.png");  p_wa = resource_path("icons/whatsapp.png"); p_ml = resource_path("icons/mail.png")
        def _section_payload() -> str:
            if not self.ensure_section_unlocked(path_list):
                return ""
            key = "/".join(path_list)
            texts = []
            for k, arr in self.blocks_data.items():
                if k == key or k.startswith(key + "/"):
                    for b in arr:
                        texts.append(self._format_block_share_text(b, reveal=True))
            return "\n\n".join(texts) if texts else "(Ð¿ÑƒÑÑ‚Ð¾)"
        a_tg = QAction("Telegram", self)
        if os.path.exists(p_tg): a_tg.setIcon(QIcon(p_tg))
        a_tg.triggered.connect(lambda: self.share_text_telegram(_section_payload()))
        share_menu.addAction(a_tg)
        a_wa = QAction("WhatsApp", self)
        if os.path.exists(p_wa): a_wa.setIcon(QIcon(p_wa))
        a_wa.triggered.connect(lambda: self.share_text_whatsapp(_section_payload()))
        share_menu.addAction(a_wa)
        a_ml = QAction("Email", self)
        if os.path.exists(p_ml): a_ml.setIcon(QIcon(p_ml))
        a_ml.triggered.connect(lambda: self._share_email("Ð”Ð°Ð½Ð½Ñ‹Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°", _section_payload(), None))
        share_menu.addAction(a_ml)
        menu.exec(self.tree.viewport().mapToGlobal(pos))
    def _path_from_item(self, item) -> list[str]:
        path = []
        cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0)); cur = cur.parent()
        return path
    def _node_by_path(self, path_list: list[str]) -> dict | None:
        node, _ = self.find_node(path_list)
        return node
    def is_path_locked(self, path_list: list[str]) -> bool:
        n = self._node_by_path(path_list)
        return bool(n and n.get("lock"))
    def set_section_password(self, path_list: list[str]):
        if not path_list: return
        p1 = self.ask_password("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°", f"Ð—Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Â«{'/'.join(path_list)}Â»:")
        if p1 is None or len(p1) < 4:
            custom_warning(self, "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ", "ÐœÐ¸Ð½Ð¸Ð¼ÑƒÐ¼ 4 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°."); return
        p2 = self.ask_password("ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ", "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ:")
        if p2 != p1:
            custom_warning(self, "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ", "ÐÐµ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÐµÑ‚."); return
        salt = rand_bytes(16)
        ver = hash_for_auth(p1, salt, prefer_argon=True)
        n = self._node_by_path(path_list)
        if n is not None:
            n["lock"] = {
                "salt": base64.b64encode(salt).decode("utf-8"),
                "verifier": ver,
                "kdf": "argon2id" if HAS_ARGON2 else "pbkdf2"
            }
            self.save_tree(); self.render_tree()
            custom_info(self, "Ð Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.")
    def clear_section_password(self, path_list: list[str]):
        if not path_list: return
        n = self._node_by_path(path_list)
        if not n or "lock" not in n:
            custom_info(self, "Ð Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½."); return
        if not self._verify_section_password(path_list):
            return
        n.pop("lock", None)
        self.unlocked_sections.discard("/".join(path_list))
        self.save_tree(); self.render_tree()
        custom_info(self, "Ð Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ ÑÐ½ÑÑ‚.")
    def _verify_section_password(self, path_list: list[str]) -> bool:
        n = self._node_by_path(path_list)
        if not n or "lock" not in n:
            return True
        pwd = self.ask_password("Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ", f"ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Â«{'/'.join(path_list)}Â»:")
        if pwd is None: return False
        lock = n["lock"] or {}
        salt = base64.b64decode(lock.get("salt","") or b"")
        kdf = lock.get("kdf","argon2id")
        calc = hash_for_auth(pwd, salt, prefer_argon=(kdf=="argon2id"))
        if calc == lock.get("verifier"):
            self.unlocked_sections.add("/".join(path_list))
            return True
        custom_error(self, "Ð”Ð¾ÑÑ‚ÑƒÐ¿", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.")
        return False
    def ensure_section_unlocked(self, path_list: list[str]) -> bool:
        if not self.is_path_locked(path_list): return True
        key = "/".join(path_list)
        if key in self.unlocked_sections: return True
        return self._verify_section_password(path_list)
    def can_show_block_data(self, block) -> bool:
        if not self.show_data:
            return False
        ref = self.id_to_ref.get(block.get("id",""))
        key = ref[0] if ref else ""
        path_list = [p for p in key.split("/") if p]
        locked = self._locked_prefixes(path_list)
        if not locked:
            return True
        return all(p in self.unlocked_sections for p in locked)
    def _win_copy_files_to_clipboard(self, files: list[str]) -> None:
        class DROPFILES(ctypes.Structure):
            _fields_ = [
                ("pFiles", ctypes.c_uint32),
                ("pt_x", ctypes.c_long),
                ("pt_y", ctypes.c_long),
                ("fNC", ctypes.c_int32),
                ("fWide", ctypes.c_int32),
            ]
        if not files:
            raise ValueError("empty file list")
        files = [os.path.abspath(p) for p in files]
        files_w = ("\0".join(files) + "\0\0").encode("utf-16le")
        header = DROPFILES()
        header.pFiles = ctypes.sizeof(DROPFILES)
        header.pt_x = 0
        header.pt_y = 0
        header.fNC = 0
        header.fWide = 1
        total = ctypes.sizeof(DROPFILES) + len(files_w)
        GMEM_MOVEABLE = 0x0002
        GMEM_ZEROINIT = 0x0040
        GHND = GMEM_MOVEABLE | GMEM_ZEROINIT
        hglobal = ctypes.windll.kernel32.GlobalAlloc(GHND, total)
        if not hglobal:
            raise RuntimeError("GlobalAlloc failed")
        ptr = ctypes.windll.kernel32.GlobalLock(hglobal)
        if not ptr:
            ctypes.windll.kernel32.GlobalFree(hglobal)
            raise RuntimeError("GlobalLock failed")
        try:
            ctypes.memmove(ptr, ctypes.byref(header), ctypes.sizeof(DROPFILES))
            ctypes.memmove(ctypes.c_void_p(ptr + ctypes.sizeof(DROPFILES)), files_w, len(files_w))
        finally:
            ctypes.windll.kernel32.GlobalUnlock(hglobal)
        CF_HDROP = 15
        if ctypes.windll.user32.OpenClipboard(None) == 0:
            ctypes.windll.kernel32.GlobalFree(hglobal)
            raise RuntimeError("OpenClipboard failed")
        try:
            ctypes.windll.user32.EmptyClipboard()
            if ctypes.windll.user32.SetClipboardData(CF_HDROP, hglobal) == 0:
                ctypes.windll.kernel32.GlobalFree(hglobal)
                raise RuntimeError("SetClipboardData failed")
            hglobal = None
        finally:
            ctypes.windll.user32.CloseClipboard()
    def _win_focus_whatsapp(self) -> None:
        try:
            from ctypes import wintypes
            user32 = ctypes.windll.user32
            EnumWindows = user32.EnumWindows
            EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
            GetWindowTextW = user32.GetWindowTextW
            GetWindowTextLengthW = user32.GetWindowTextLengthW
            IsWindowVisible = user32.IsWindowVisible
            SetForegroundWindow = user32.SetForegroundWindow
            ShowWindow = user32.ShowWindow
            SW_RESTORE = 9
            target = {"hwnd": None}
            def _enum_cb(hwnd, _lparam):
                try:
                    if not IsWindowVisible(hwnd):
                        return True
                    length = GetWindowTextLengthW(hwnd)
                    if length == 0:
                        return True
                    buf = ctypes.create_unicode_buffer(length + 1)
                    GetWindowTextW(hwnd, buf, length + 1)
                    title = buf.value
                    if "WhatsApp" in title:
                        target["hwnd"] = hwnd
                        return False
                except Exception:
                    pass
                return True
            EnumWindows(EnumWindowsProc(_enum_cb), 0)
            if target["hwnd"]:
                ShowWindow(target["hwnd"], SW_RESTORE)
                SetForegroundWindow(target["hwnd"])
        except Exception:
            pass
    def _win_send_ctrl_v(self) -> None:
        try:
            CREATE_NO_WINDOW = 0x08000000
            ps = (
                'Add-Type -AssemblyName System.Windows.Forms; '
                '[System.Windows.Forms.SendKeys]::SendWait("^v"); '
            )
            subprocess.Popen(
                ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", ps],
                creationflags=CREATE_NO_WINDOW
            )
        except Exception:
            pass
    def _menu_set_lock(self, item):
        path_list = self._path_from_item(item)
        self.set_section_password(path_list)
    def _menu_clear_lock(self, item):
        path_list = self._path_from_item(item)
        self.clear_section_password(path_list)
    def share_section_by_menu(self, item):
        path_list = self._path_from_item(item)
        if not self.ensure_section_unlocked(path_list):
            return
        key = "/".join(path_list)
        texts = []
        for k, arr in self.blocks_data.items():
            if k == key or k.startswith(key + "/"):
                for b in arr:
                    texts.append(self._format_block_share_text(b))
        payload = "\n\n".join(texts) if texts else "(Ð¿ÑƒÑÑ‚Ð¾)"
        m = QMenu(self)
        ico_tg   = QIcon(resource_path("icons/telegram.png")) if os.path.exists(resource_path("icons/telegram.png")) else QIcon()
        ico_wa   = QIcon(resource_path("icons/whatsapp.png")) if os.path.exists(resource_path("icons/whatsapp.png")) else QIcon()
        ico_mail = QIcon(resource_path("icons/mail.png"))     if os.path.exists(resource_path("icons/mail.png"))     else QIcon()
        a_tg   = QAction(ico_tg,   "Telegram", self)
        a_wa   = QAction(ico_wa,   "WhatsApp", self)
        a_mail = QAction(ico_mail, "Email",    self)
        a_tg.triggered.connect(lambda: self.share_text_telegram(payload))
        a_wa.triggered.connect(lambda: self.share_text_whatsapp(payload))
        a_mail.triggered.connect(lambda: self._share_email("Ð”Ð°Ð½Ð½Ñ‹Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°", payload, None))
        m.addAction(a_tg); m.addAction(a_wa); m.addAction(a_mail)
        m.exec(QCursor.pos())
    def _paranoid_export_json_bytes(self, scope_key: str | None = None) -> bytes:
        def enc(s: str) -> str:
            return base64.urlsafe_b64encode(self.fernet.encrypt((s or "").encode("utf-8"))).decode("utf-8").rstrip("=")
        items = []
        def push(k: str, b: dict):
            items.append({
                "k": enc(k),
                "t": enc(b.get("title","")),
                "f": [[enc(name), enc(decrypt_value(val, self.fernet))] for name, val in (b.get("fields") or {}).items()]
            })
        if scope_key:
            pref = scope_key + "/" if scope_key else ""
            for k, arr in self.blocks_data.items():
                if k == scope_key or k.startswith(pref):
                    for b in arr: push(k, b)
        else:
            for k, arr in self.blocks_data.items():
                for b in arr: push(k, b)
        payload = {"ver": CURRENT_VERSION, "ts": datetime.utcnow().isoformat()+"Z", "items": items}
        return json.dumps(payload, ensure_ascii=False, indent=2).encode("utf-8")

    def export_paranoid_lpx1(self):
        pwd = self.ask_password("Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ (LPX1)", "Ð—Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð½Ð° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚:")
        if pwd is None or len(pwd) < 4:
            custom_warning(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", "ÐšÐ¾Ñ€Ð¾Ñ‚ÐºÐ¸Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.")
            return
        raw = self._paranoid_export_json_bytes(None)
        data = _lpx_encrypt_bytes(raw, pwd)

        path, _ = QFileDialog.getSaveFileName(
            self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚ (LPX1, Ð²ÑÐµ Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹)",
            "export_all.lpx", "LPX1 (*.lpx)"
        )
        if not path:
            return
        try:
            with open(path, "wb") as f:
                f.write(data)
            custom_info(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾. Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð²ÑÐµ Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð¸ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹.")
            audit_write("export_lpx1", {"scope": "ALL", "file": path})
        except Exception as e:
            custom_error(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def backup_data_lpx1(self):
        pwd = self.ask_password("Ð‘ÑÐºÐ°Ð¿ (LPX1)", "Ð—Ð°Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð±ÑÐºÐ°Ð¿Ð°:")
        if pwd is None or len(pwd) < 4:
            custom_warning(self, "Ð‘ÑÐºÐ°Ð¿", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½ Ð¸Ð»Ð¸ ÐºÐ¾Ñ€Ð¾Ñ‚ÐºÐ¸Ð¹.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð±ÑÐºÐ°Ð¿ (LPX1)", "data_backup.lpx", "LPX1 (*.lpx)")
        if not path:
            return
        def _make_zip() -> bytes:
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as z:
                for fn in (TREE_FILE, BLOCKS_FILE, TRASH_FILE, META_FILE, MASTER_FILE, INDEX_DB):
                    if os.path.exists(fn):
                        z.write(fn, os.path.basename(fn))
                for root, _, files in os.walk(ATTACH_DIR):
                    for f in files:
                        fp = os.path.join(root, f)
                        arc = os.path.relpath(fp, DATA_DIR)
                        z.write(fp, arc)
            return buf.getvalue()
        def work():
            raw = _make_zip()
            enc = _lpx_encrypt_bytes(raw, pwd)
            with open(path, "wb") as f:
                f.write(enc)
            return path
        def done(p):
            custom_info(self, "Ð‘ÑÐºÐ°Ð¿", "Ð—Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð±ÑÐºÐ°Ð¿ ÑÐ¾Ð·Ð´Ð°Ð½.")
            audit_write("backup_lpx1", {"file": p})
        run_long_task(self, "Ð‘ÑÐºÐ°Ð¿", work, done)
    def _make_full_backup_zip_bytes(self) -> bytes:
        buf = io.BytesIO()
        with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as z:
            for fn in (TREE_FILE, BLOCKS_FILE, TRASH_FILE, META_FILE, MASTER_FILE, INDEX_DB):
                if os.path.exists(fn):
                    z.write(fn, os.path.basename(fn))
            for root, _, files in os.walk(ATTACH_DIR):
                for f in files:
                    fp = os.path.join(root, f)
                    arc = os.path.relpath(fp, DATA_DIR)
                    z.write(fp, arc)
        return buf.getvalue()
    def create_item(self):
        name, ok = QInputDialog.getText(self, "ÐÐ¾Ð²Ñ‹Ð¹ Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°:")
        if not (ok and name): return
        clean = name.replace("\ufeff", "").strip()
        if not clean: clean = "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)"
        self.data_tree.append({"name": clean, "children": [], "color": self.theme.get("tag_bg", "#f4e4ae")})
        self.save_tree(); self.render_tree(); self.schedule_render()
        audit_write("create_section", {"name": clean})
    def create_subsection_by_sel(self):
        items = self.tree.selectedItems()
        if not items:
            custom_info(self, "ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ».")
            return
        self.create_subitem(items[0])
    def create_subitem(self, parent_item):
        name, ok = QInputDialog.getText(self, "ÐÐ¾Ð²Ñ‹Ð¹ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ð°:")
        if not (ok and name): return
        clean = name.replace("\ufeff", "").strip()
        if not clean: clean = "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)"
        def rec(nodes, names):
            if not names:
                return nodes
            head = names[0]
            n = next((x for x in nodes if x["name"] == head), None)
            if not n:
                n = {"name": head, "children": [], "color": self.theme.get("tag_bg", "#f4e4ae")}
                nodes.append(n)
            if len(names) == 1:
                return n["children"]
            return rec(n["children"], names[1:])
        path = []
        cur = parent_item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0)); cur = cur.parent()
        children = rec(self.data_tree, path)
        children.append({"name": clean, "children": [], "color": self.theme.get("tag_bg", "#f4e4ae")})
        self.save_tree(); self.render_tree(); self.schedule_render()
        audit_write("create_subsection", {"parent": "/".join(path), "name": clean})
    def rename_item(self, item):
        old_path = []; cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            old_path.insert(0, cur.text(0)); cur = cur.parent()
        old_name = old_path[-1] if old_path else ""
        name, ok = QInputDialog.getText(self, "ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ñ‚ÑŒ", "ÐÐ¾Ð²Ð¾Ðµ Ð¸Ð¼Ñ:", text=old_name)
        if not (ok and name): return
        clean = name.replace("\ufeff", "").strip()
        if not clean:
            custom_warning(self, "ÐŸÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ", "Ð˜Ð¼Ñ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼.")
            return
        parent_list, node, idx = self.find_parent_and_index(old_path)
        if node is None: return
        node["name"] = clean
        old_prefix = "/".join(old_path)
        new_prefix = "/".join(old_path[:-1] + [clean])
        self._rename_blocks_prefix(old_prefix, new_prefix)
        self.save_tree(); self.save_blocks()
        self.render_tree(); self.schedule_render()
        audit_write("rename_section", {"from": old_prefix, "to": new_prefix})
    def delete_item_by_sel(self):
        it = self.tree.currentItem()
        if it: self.delete_item(it)
    def delete_item(self, item):
        path = []; cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0)); cur = cur.parent()
        if not path: return
        key_prefix = "/".join(path)
        res = custom_question(self, "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»?",
            f"Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ» Â«{key_prefix}Â» Ð¸ Ð²ÑÐµ ÐµÐ³Ð¾ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð¸ Ð±Ð»Ð¾ÐºÐ¸?\n(Ð‘Ð»Ð¾ÐºÐ¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ñ‹ Ð² ÐšÐ¾Ñ€Ð·Ð¸Ð½Ñƒ)")
        if not res: return
        def remove_from(nodes, names):
            if not names: return False
            head = names[0]
            for i, n in enumerate(nodes):
                if n["name"] == head:
                    if len(names) == 1:
                        nodes.pop(i); return True
                    return remove_from(n.get("children", []), names[1:])
            return False
        affected_keys = [k for k in list(self.blocks_data.keys()) if k == key_prefix or k.startswith(key_prefix + "/")]
        for k in affected_keys:
            for b in self.blocks_data.get(k, []):
                self.trash.append({"id": b["id"], "from_key": k, "block": b, "ts": datetime.utcnow().isoformat()+"Z"})
                self.remove_index_for_block(b)
            del self.blocks_data[k]
        self.save_trash()
        remove_from(self.data_tree, path)
        self.save_tree(); self.save_blocks()
        self.render_tree(); self.schedule_render()
        audit_write("delete_section", {"path": key_prefix, "moved_blocks": len(affected_keys)})
    def set_section_color(self, item):
        path = []
        cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0)); cur = cur.parent()
        cur_color = self.get_section_color(path)
        qcol = QColorDialog.getColor(QColor(cur_color), self, "Ð¦Ð²ÐµÑ‚ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°")
        if not qcol.isValid():
            return
        color = qcol.name()
        def rec(nodes, names):
            if not names: return False
            head = names[0]
            for n in nodes:
                if n["name"] == head:
                    if len(names) == 1:
                        n["color"] = color; return True
                    return rec(n["children"], names[1:])
            return False
        rec(self.data_tree, path)
        self.save_tree(); self.render_tree(); self.schedule_render()
        audit_write("set_section_color", {"path": "/".join(path), "color": color})
    def move_section_by_menu(self, item):
        path = []; cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0)); cur = cur.parent()
        if not path: return
        all_paths = ["(ÐºÐ¾Ñ€ÐµÐ½ÑŒ)"] + self.get_all_paths()
        forbidden_prefix = "/".join(path)
        target, ok = QInputDialog.getItem(self, "ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐÐ¾Ð²Ñ‹Ð¹ Ñ€Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒ:", all_paths, 0, False)
        if not (ok and target): return
        if target == "/".join(path[:-1]) or (target != "(ÐºÐ¾Ñ€ÐµÐ½ÑŒ)" and target.startswith(forbidden_prefix)):
            custom_warning(self, "ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ", "ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ.")
            return
        new_parent = "" if target == "(ÐºÐ¾Ñ€ÐµÐ½ÑŒ)" else target
        self._move_section(path, new_parent)
    from typing import List, Optional
    def _move_section(self, path_list: List[str], new_parent_path: str) -> None:
        if not path_list:
            return
        parent_list, node, idx = self.find_parent_and_index(path_list)
        if node is None or parent_list is None or idx < 0:
            return
        del parent_list[idx]
        def get_children_of(path_str: Optional[str]) -> List[dict]:
            if not path_str:
                return self.data_tree
            parts = path_str.split("/")
            n, _ = self.find_node(parts)
            if n is None:
                return self.data_tree
            return n.setdefault("children", [])
        children = get_children_of(new_parent_path)
        children.append(node)
        old_prefix = "/".join(path_list)
        new_prefix = (new_parent_path + "/" if new_parent_path else "") + path_list[-1]
        self._rename_blocks_prefix(old_prefix, new_prefix)
        self.save_tree()
        self.save_blocks()
        self.render_tree()
        self.schedule_render()
        audit_write("move_section", {"from": old_prefix, "to": new_prefix})
    def _rename_blocks_prefix(self, old_prefix, new_prefix):
        updates = {}
        for k in list(self.blocks_data.keys()):
            if k == old_prefix or k.startswith(old_prefix + "/"):
                suffix = k[len(old_prefix):]
                if suffix.startswith("/"): suffix = suffix[1:]
                newk = new_prefix + (("/" + suffix) if suffix else "")
                updates[k] = newk
        for k, nk in updates.items():
            self.blocks_data.setdefault(nk, []).extend(self.blocks_data[k])
            del self.blocks_data[k]
        for k, arr in self.blocks_data.items():
            for b in arr:
                b["category"] = k.split("/")[-1] if k else b.get("category","")
                self.id_to_ref[b["id"]] = (k, b)
                self.update_index_for_block(b)
    def render_dashboard(self):
        if getattr(self, "_rendering", False):
            return
        self._rendering = True
        _vpos = 0
        _hpos = 0

        try:
            try:
                if hasattr(self, "kanban_area") and self.kanban_area is not None:
                    _vpos = self.kanban_area.verticalScrollBar().value()
                    _hpos = self.kanban_area.horizontalScrollBar().value()
            except Exception:
                _vpos = 0
                _hpos = 0
            while True:
                item = self.kanban_layout.takeAt(0)
                if not item:
                    break
                w = item.widget()
                if w is not None:
                    w.deleteLater()
            t = self.theme
            r = int(t.get("btn_radius", 10))
            fg = t.get("btn_fg", "#FFF")
            self.btn_add_block.setStyleSheet(
                f"padding:6px 12px;background:{t['btn_add_section_bg']};"
                f"color:{fg};border:none;border-radius:{r}px;"
            )
            self.btn_toggle_data.setStyleSheet(
                f"padding:6px 12px;background:{t['btn_move_bg']};"
                f"color:{fg};border:none;border-radius:{r}px;"
            )
            self.kanban_content.setUpdatesEnabled(False)
            try:
                cp = self.current_path if isinstance(self.current_path, list) else []
                if cp and cp[0] == "__SMART__":
                    self.render_smart_folder()
                    return
                if cp:
                    locked_prefixes = self._locked_prefixes(cp)
                    if any(p not in self.unlocked_sections for p in locked_prefixes):
                        stub = QFrame()
                        sl = QVBoxLayout(stub)
                        lab = QLabel(f"ðŸ”’ Ð Ð°Ð·Ð´ÐµÐ» Â«{'/'.join(cp)}Â» Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½.")
                        lab.setAlignment(Qt.AlignmentFlag.AlignCenter)
                        btn = QPushButton("Ð Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ")
                        btn.setProperty("minsize", "compact")
                        btn.clicked.connect(lambda: self.ensure_chain_unlocked(cp) and self.schedule_render())
                        sl.addWidget(lab)
                        sl.addWidget(btn, 0, Qt.AlignmentFlag.AlignHCenter)
                        self.kanban_layout.addWidget(stub)
                        return
                key = self.current_key()
                blocks: list[dict] = []
                if key:
                    pref = key + "/"
                    for k in self.blocks_data.keys():
                        if k == key or k.startswith(pref):
                            blocks.extend(self.blocks_data.get(k, []))
                search = (self.search_input.text() or "").strip()
                mode = self.search_mode
                if search:
                    ids = set(self.index.search(search))
                    if mode == "Ð‘Ð»Ð¾ÐºÐ¸":
                        blocks = [b for b in blocks if b.get("id") in ids]
                    else:
                        ql = search.lower()
                        blocks = [
                            b for b in blocks
                            if any(
                                ql in (k or "").lower()
                                or ql in (decrypt_value(v, self.fernet) or "").lower()
                                for k, v in (b.get("fields") or {}).items()
                            )
                        ]
                if self.btn_att_only.isChecked():
                    blocks = [b for b in blocks if attachments_count(b.get("id", "")) > 0]
                if not blocks:
                    self.kanban_layout.addWidget(QLabel("ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…"))
                    return
                total = len(blocks)
                truncated = False
                if total > MAX_CARDS:
                    blocks = blocks[:MAX_CARDS]
                    truncated = True
                for block in blocks:
                    ref = self.id_to_ref.get(block.get("id", ""))
                    blk_key = ref[0] if ref else key
                    blk_path = [p for p in (blk_key or "").split("/") if p]
                    blk_color = self.get_section_color(blk_path)
                    self.kanban_layout.addWidget(self.make_block_card(block, blk_color))
                if truncated:
                    info = QLabel(f"ÐŸÐ¾ÐºÐ°Ð·Ð°Ð½Ñ‹ Ð¿ÐµÑ€Ð²Ñ‹Ðµ {MAX_CARDS} Ð¸Ð· {total}. Ð£Ñ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¸ÑÐº.")
                    self.kanban_layout.addWidget(info)
            finally:
                self.kanban_content.setUpdatesEnabled(True)
                try:
                    self.kanban_area.verticalScrollBar().setValue(_vpos)
                    self.kanban_area.horizontalScrollBar().setValue(_hpos)
                except Exception:
                    pass
        finally:
            self._rendering = False
    def render_smart_folder(self):
        sf_name = self.current_path[1] if len(self.current_path) > 1 else ""
        sf = next((x for x in (self.meta.get("smart_folders") or []) if x.get("name") == sf_name), None)
        if not sf:
            self.kanban_layout.addWidget(QLabel("Ð£Ð¼Ð½Ð°Ñ Ð¿Ð°Ð¿ÐºÐ° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°"))
            return
        query = (sf.get("query") or "").strip()
        scope = (sf.get("scope") or "").strip()
        mode  = sf.get("mode", "ÐŸÐ¾Ð»Ñ")
        if scope and scope != "ALL":
            keys = [k for k in self.blocks_data.keys() if k == scope or k.startswith(scope + "/")]
        else:
            keys = list(self.blocks_data.keys())
        blocks: list[dict] = []
        if query:
            ids = set(self.index.search(query))
            ql = query.lower()
            for k in keys:
                for b in self.blocks_data.get(k, []):
                    if mode == "Ð‘Ð»Ð¾ÐºÐ¸":
                        if b.get("id") in ids:
                            blocks.append(b)
                    else:
                        fs = b.get("fields") or {}
                        if any(
                            (ql in (name or "").lower()) or (ql in (decrypt_value(val, self.fernet) or "").lower())
                            for name, val in fs.items()
                        ):
                            blocks.append(b)
        else:
            for k in keys:
                blocks.extend(self.blocks_data.get(k, []))

        if self.btn_att_only.isChecked():
            blocks = [b for b in blocks if attachments_count(b.get("id", "")) > 0]

        if not blocks:
            self.kanban_layout.addWidget(QLabel("ÐÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²"))
            return
        total = len(blocks)
        truncated = False
        if total > MAX_CARDS:
            blocks = blocks[:MAX_CARDS]
            truncated = True
        for b in blocks:
            ref = self.id_to_ref.get(b.get("id", ""))
            blk_key = ref[0] if ref else ""
            blk_path = [p for p in (blk_key or "").split("/") if p]
            blk_color = self.get_section_color(blk_path)
            self.kanban_layout.addWidget(self.make_block_card(b, blk_color))
        if truncated:
            self.kanban_layout.addWidget(QLabel(f"ÐŸÐ¾ÐºÐ°Ð·Ð°Ð½Ñ‹ Ð¿ÐµÑ€Ð²Ñ‹Ðµ {MAX_CARDS} Ð¸Ð· {total}. Ð£Ñ‚Ð¾Ñ‡Ð½Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¸ÑÐº."))
    def open_attachments(self, block):
        ref = self.id_to_ref.get(block.get("id","")); key = ref[0] if ref else ""
        path_list = [p for p in key.split("/") if p]
        if not self.ensure_chain_unlocked(path_list):
            return
        try:
            BlockEditorDialog(self, block, open_tab="attachments").exec()
        except Exception as e:
            custom_warning(self, "Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def _build_qr_plaintext(self, block: dict) -> str:
        title = block.get("title", "") or "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)"
        category = block.get("category", "") or ""
        lines = [f"{title} ({category})" if category else title]
        for k, v in (block.get("fields") or {}).items():
            plain = decrypt_value(v, self.fernet)
            lines.append(f"{k}: {plain}")
        notes_plain = decrypt_value(block.get("notes", ""), self.fernet)
        if (notes_plain or "").strip():
            lines.append("Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸:")
            lines.append(notes_plain)
        return "\n".join(lines)
    def open_notes(self, block):
        ref = self.id_to_ref.get(block.get("id",""))
        key = ref[0] if ref else ""
        path_list = [p for p in (key or "").split("/") if p]
        if not self.ensure_chain_unlocked(path_list):
            return
        try:
            BlockEditorDialog(self, block, open_tab="notes").exec()
        except Exception as e:
            custom_warning(self, "Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def make_block_card(self, block: dict, color: str):
        t = self.theme
        r = int(t.get("btn_radius", 10))
        card = QFrame()
        card.setObjectName("BlockCard")
        card.setAttribute(Qt.WidgetAttribute.WA_Hover, True)
        card.setFixedWidth(300)
        from PySide6.QtWidgets import QSizePolicy
        card.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)
        vb = QVBoxLayout(card)
        vb.setContentsMargins(12, 12, 12, 12)
        vb.setSpacing(8)
        top = QHBoxLayout()
        title = QLabel(block.get("title", ""))
        title.setStyleSheet(
             f"font-weight:700; font-size:16px; letter-spacing:0.2px; color:{t['block_title_fg']};"
        )
        title.setWordWrap(True)
        top.addWidget(title)
        top_right_layout = QHBoxLayout()
        top_right_layout.setSpacing(6)
        tag = QLabel(block.get("category", ""))
        tag_fg = self._contrast_text_for(color)
        tag.setStyleSheet(
            f"background:{color}; color:{tag_fg}; "
            "font-size:11px; font-weight:600; "
            "border-radius:10px; padding:4px 8px; min-height:18px; max-height:18px;"
        )
        top_right_layout.addWidget(tag)
        att_n = attachments_count(block.get("id", ""))
        if att_n > 0:
            att_lbl = QLabel(f"ðŸ“Ž {att_n}")
            att_lbl.setToolTip(f"Ð’Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹: {att_n}")
            att_lbl.setStyleSheet(
                f"background:{t['attach_badge_bg']}; color:{t['attach_badge_fg']}; "
                "font-size:11px; border-radius:7px; padding:5px; min-height:18px; max-height:18px;"
            )
            top_right_layout.addWidget(att_lbl)
        btn_share = QPushButton()
        share_ico = resource_path("icons/share.png")
        if os.path.exists(share_ico):
            btn_share.setIcon(QIcon(share_ico))
            btn_share.setIconSize(QtCore.QSize(16, 16))
        else:
            btn_share.setText("ðŸ”—")
        btn_share.setProperty("minsize", "compact")
        btn_share.setToolTip("ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ")
        btn_share.clicked.connect(lambda _, b=block: self.share_block(b))
        top_right_layout.addWidget(btn_share)
        try:
            btn_qr = QPushButton()
            qr_ico = resource_path("icons/qr.png")
            if os.path.exists(qr_ico):
                btn_qr.setIcon(QIcon(qr_ico))
                btn_qr.setIconSize(QtCore.QSize(16, 16))
            else:
                btn_qr.setText("QR")
            btn_qr.setProperty("minsize", "compact")
            btn_qr.setToolTip("ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ QR")
            btn_qr.clicked.connect(lambda _, b=block: self.show_block_qr(b))
            top_right_layout.addWidget(btn_qr)
        except Exception:
            pass
        ref = self.id_to_ref.get(block.get("id", ""))
        key = ref[0] if ref else ""
        path_list = [p for p in (key or "").split("/") if p]
        locked_prefixes = self._locked_prefixes(path_list)
        if any(p not in self.unlocked_sections for p in locked_prefixes):
            btn_unlock = QPushButton("ðŸ”“")
            btn_unlock.setProperty("minsize", "compact")
            btn_unlock.setToolTip("Ð Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ» Ð´Ð»Ñ Ð¿Ð¾ÐºÐ°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…")
            def _do_unlock():
                if self.ensure_section_unlocked(path_list):
                    self.schedule_render()
            btn_unlock.clicked.connect(_do_unlock)
            top_right_layout.addWidget(btn_unlock)
        top.addLayout(top_right_layout)
        vb.addLayout(top)
        fields = (block.get("fields") or {})
        can_show = self.can_show_block_data(block)
        items = list(fields.items())
        limit = CARD_FIELDS_LIMIT if isinstance(CARD_FIELDS_LIMIT, int) and CARD_FIELDS_LIMIT > 0 else 6
        shown_cnt = 0
        for (k, vv) in items[:limit]:
            row = QHBoxLayout()
            lab = QLabel(str(k if k is not None else "").rstrip(":") + ":")
            lab.setStyleSheet(
                f"font-size:12px; font-weight:600; margin-right:6px; min-width:50px; color:{t['field_label_fg']};"
            )
            row.addWidget(lab)
            if can_show:
                val_plain = decrypt_value(vv, self.fernet)
                txt = val_plain
            else:
                val_plain = None
                txt = mask_text("")
            edit = QLineEdit(txt)
            edit.setReadOnly(True)
            edit.setStyleSheet(
                "QLineEdit {"
                "  background:#FAFAFB; border:1px solid #ECECEE; border-radius:8px;"
                "  padding:6px 8px; font-size:13px;"
                f"  color:{t['field_text_fg']};"
                "}"
            )
            row.addWidget(edit)
            if can_show and val_plain and (is_url(val_plain) or is_email_addr(val_plain)):
                btn_go = QPushButton("â†—")
                btn_go.setFixedWidth(28)
                btn_go.setProperty("minsize", "compact")
                btn_go.clicked.connect(lambda _=False, url=val_plain: QDesktopServices.openUrl(to_qurl_from_text(url)))
                row.addWidget(btn_go)
            btn_copy = QPushButton("ðŸ—")
            btn_copy.setFixedWidth(28)
            btn_copy.setProperty("minsize", "compact")
            def _copy_now(_checked=False, enc_val=vv, pl=tuple(path_list)):
                if not self.ensure_chain_unlocked(list(pl)):
                    return
                try:
                    plain = decrypt_value(enc_val, self.fernet)
                except Exception:
                    plain = ""
                QApplication.clipboard().setText(str(plain))
                self.clip_timer.start(self.CLIPBOARD_SEC * 1000)
            btn_copy.clicked.connect(_copy_now)
            row.addWidget(btn_copy)
            vb.addLayout(row)
            shown_cnt += 1
        rest = max(0, len(items) - shown_cnt)
        if rest > 0:
            more = QLabel(f"â€¦ Ð¸ ÐµÑ‰Ñ‘ {rest} Ð¿Ð¾Ð»ÐµÐ¹")
            more.setStyleSheet("font-size:12px; color:#666; margin-top:4px;")
            vb.addWidget(more)
        rowb = QHBoxLayout()
        def _btn_grey(text: str, tooltip: str, handler):
            b = QPushButton(text)
            b.setToolTip(tooltip)
            b.setStyleSheet(
                "padding:6px 10px; font-size:13px;"
                "background:transparent; color:#1F2937;"
                "border:1px solid #E6E7EA; border-radius:%dpx;"
                "QPushButton:hover { background:#F7F8FA; }" % r
            )
            b.clicked.connect(handler)
            return b
        b_open  = _btn_grey("ðŸ”", "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð±Ð»Ð¾Ðº",       lambda _, b=block: self.safe_open_block_editor(b))
        b_move  = _btn_grey("â†”ï¸", "ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ð»Ð¾Ðº",   lambda _, b=block: self.move_block_dialog(b))
        b_files = _btn_grey("ðŸ“", "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",   lambda _, b=block: self.open_attachments(b))
        b_notes = _btn_grey("ðŸ“", "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð·Ð°Ð¼ÐµÑ‚ÐºÐ¸",    lambda _, b=block: self.open_notes(b))
        b_del   = _btn_grey("ðŸ—‘ï¸", "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð±Ð»Ð¾Ðº",       lambda _, b=block: self.delete_block_soft(b))
        rowb.addWidget(b_open)
        rowb.addWidget(b_move)
        rowb.addWidget(b_files)
        rowb.addWidget(b_notes)
        rowb.addStretch(1)
        rowb.addWidget(b_del)
        vb.addLayout(rowb)
        def _drag_start(event, bid=block["id"]):
            if event.button() != Qt.MouseButton.LeftButton:
                return
            mime = QtCore.QMimeData()
            mime.setData("application/x-linkpass-block-id", bid.encode("utf-8"))
            drag = QDrag(self)
            drag.setMimeData(mime)
            drag.exec(Qt.DropAction.MoveAction)
        card.mousePressEvent = _drag_start
        return card
    def _format_block_share_text(self, block, reveal: bool = False) -> str:
        parts = [f"ðŸ” {block.get('title','')} ({block.get('category','')})"]
        can_show = reveal or self.can_show_block_data(block)
        for k, v in (block.get("fields") or {}).items():
            val = decrypt_value(v, self.fernet) if can_show else "[ÑÐºÑ€Ñ‹Ñ‚Ð¾]"
            parts.append(f"{k}: {val}")
        return "\n".join(parts)
    def _guess_telegram_exe(self) -> str | None:
        candidates = [
            os.path.join(os.environ.get("APPDATA",""), "Telegram Desktop", "Telegram.exe"),
            os.path.join(os.environ.get("LOCALAPPDATA",""), "Programs", "Telegram Desktop", "Telegram.exe"),
            os.path.join(os.environ.get("LOCALAPPDATA",""), "Telegram Desktop", "Telegram.exe"),
            "Telegram.exe",
        ]
        for p in candidates:
            try:
                if p and os.path.isfile(p):
                    return p
            except Exception:
                pass
        return None
    def share_files_telegram(self, files: list[str]) -> None:
        files = [f for f in files if f and os.path.isfile(f)]
        if not files:
            custom_warning(self, "Telegram", "ÐÐµÑ‚ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.")
            return
        exe = self._guess_telegram_exe()
        if exe:
            try:
                for f in files:
                    subprocess.Popen([exe, "-sendpath", f])
                custom_info(self, "Telegram", "ÐžÑ‚ÐºÑ€Ñ‹Ð» Telegram Ð¸ Ð¿ÐµÑ€ÐµÐ´Ð°Ð» Ñ„Ð°Ð¹Ð»Ñ‹. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ‡Ð°Ñ‚ Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ.")
                return
            except Exception as e:
                custom_warning(self, "Telegram", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿ÐµÑ€ÐµÐ´Ð°Ñ‚ÑŒ Ð½Ð°Ð¿Ñ€ÑÐ¼ÑƒÑŽ: {e}")
        try:
            self.open_url_safe(QUrl("tg://"), "Telegram")
        except Exception:
            pass
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(files[0])))
        except Exception:
            pass
        custom_info(self, "Telegram", "Ð•ÑÐ»Ð¸ Ð½Ðµ Ð¿Ð¾ÑÐ²Ð¸Ð»Ð¾ÑÑŒ Ð¾ÐºÐ½Ð¾ Ð²Ñ‹Ð±Ð¾Ñ€Ð°, Ð¿ÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð¸Ð· Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¾Ð¹ Ð¿Ð°Ð¿ÐºÐ¸ Ð² Ð¾ÐºÐ½Ð¾ Ñ‡Ð°Ñ‚Ð° Telegram.")
    def _guess_whatsapp_exe(self) -> str | None:
        candidates = [
            os.path.join(os.environ.get("LOCALAPPDATA",""), "WhatsApp", "WhatsApp.exe"),
            os.path.join(os.environ.get("LOCALAPPDATA",""), "Programs", "WhatsApp", "WhatsApp.exe"),
            "WhatsApp.exe",
        ]
        for p in candidates:
            try:
                if p and os.path.isfile(p):
                    return p
            except Exception:
                pass
        return None
    def share_files_whatsapp(self, files: list[str]) -> None:
        files = [os.path.abspath(f) for f in files if f and os.path.isfile(f)]
        if not files:
            custom_warning(self, "WhatsApp", "ÐÐµÑ‚ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.")
            return
        opened = False
        for url in (
            "whatsapp://send?text=%20",
            "whatsapp://send",
            "https://wa.me/?text=%20",
            "https://web.whatsapp.com/send?text=%20"
        ):
            try:
                if QDesktopServices.openUrl(QUrl(url)):
                    opened = True
                    break
            except Exception:
                pass
        try:
            folder = os.path.dirname(files[0])
            QDesktopServices.openUrl(QUrl.fromLocalFile(folder))
        except Exception:
            pass
        custom_info(
            self,
            "WhatsApp",
            "ÐžÑ‚ÐºÑ€Ñ‹Ð» WhatsApp/Web. Ð•ÑÐ»Ð¸ Ð¾ÐºÐ½Ð¾ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð½Ðµ Ð¿Ð¾ÑÐ²Ð¸Ð»Ð¾ÑÑŒ, Ð¿ÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð¸Ð· Ð¿Ð°Ð¿ÐºÐ¸ Ð² Ñ‡Ð°Ñ‚."
        )
    def share_files_email(self, block: dict, files: list[str]) -> None:
        self._share_email(None, None, None)
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(files[0])))
        except Exception:
            pass
    def _open_url_any(self, url: str) -> bool:
        qurl = QUrl.fromUserInput(url)
        ok = QDesktopServices.openUrl(qurl)
        if ok:
            return True
        try:
            import webbrowser
            return webbrowser.open(url)
        except Exception:
            return False
    def _share_telegram(self, text: str) -> None:
        from urllib.parse import quote_plus
        payload = quote_plus((text or "").replace("\r\n", "\n"))
        for url in (f"https://t.me/share/url?text={payload}", f"tg://msg?text={payload}"):
            if self._open_url_any(url):
                return
        QApplication.clipboard().setText(text or "")
        custom_info(self, "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ", "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Telegram. Ð¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.")
    def share_text_whatsapp(self, text: str) -> None:
        text = (text or "(Ð¿ÑƒÑÑ‚Ð¾)").replace("\r\n", "\n")
        MAX_DEEPLINK = 2000
        MAX_WEB      = 1000
        def _try(qurl: QUrl) -> bool:
            try:
                return QDesktopServices.openUrl(qurl)
            except Exception:
                return False
        if len(text) <= MAX_DEEPLINK:
            u = QUrl("whatsapp://send")
            q = QUrlQuery()
            q.addQueryItem("text", text)
            u.setQuery(q)
            if _try(u):
                return
        if len(text) <= MAX_WEB:
            u = QUrl("https://web.whatsapp.com/send")
            q = QUrlQuery()
            q.addQueryItem("text", text)
            u.setQuery(q)
            self.open_url_safe(u, "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² WhatsApp")
            return
        if len(text) <= MAX_WEB:
            u = QUrl("https://wa.me/")
            q = QUrlQuery()
            q.addQueryItem("text", text)
            u.setQuery(q)
            self.open_url_safe(u, "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² WhatsApp")
            return
        QApplication.clipboard().setText(text)
        custom_info(self, "WhatsApp",
                    "Ð¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.\nÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ WhatsApp Ð¸ Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ (Ctrl+V).")
        exe = self._guess_whatsapp_exe()
        if exe:
            try:
                subprocess.Popen([exe])
            except Exception:
                pass
    def _share_whatsapp(self, text: str) -> None:
        self.share_text_whatsapp(text)
    def _share_email(self,
                    subject: str | None,
                    body: str | None,
                    recipients: list[str] | None = None) -> None:
        to = ",".join(recipients or [])
        u = QUrl(f"mailto:{to}")
        q = QUrlQuery()
        if subject:
            q.addQueryItem("subject", subject)
        if body:
            q.addQueryItem("body", (body or "").replace("\r\n", "\n"))
        u.setQuery(q)
        ok = False
        try:
            ok = QDesktopServices.openUrl(u)
        except Exception:
            ok = False
        if not ok:
            custom_warning(self, "ÐŸÐ¾Ñ‡Ñ‚Ð°", "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð¾Ñ‡Ñ‚Ð¾Ð²Ñ‹Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚. ÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Ð¿Ð°Ð¿ÐºÑƒ Ð¸ Ð¿Ñ€Ð¸ÐºÑ€ÐµÐ¿Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ.")
    def share_block(self, block):
        ref = self.id_to_ref.get(block.get("id","")); key = ref[0] if ref else ""
        path_list = [p for p in key.split("/") if p]
        if not self.ensure_chain_unlocked(path_list):
            return
        text = self._format_block_share_text(block, reveal=True)
        m = QMenu(self)
        ico_tg   = QIcon(resource_path("icons/telegram.png")) if os.path.exists(resource_path("icons/telegram.png")) else QIcon()
        ico_wa   = QIcon(resource_path("icons/whatsapp.png")) if os.path.exists(resource_path("icons/whatsapp.png")) else QIcon()
        ico_mail = QIcon(resource_path("icons/mail.png"))     if os.path.exists(resource_path("icons/mail.png"))     else QIcon()
        a_tg   = QAction(ico_tg,   "Telegram", self)
        a_wa   = QAction(ico_wa,   "WhatsApp", self)
        a_mail = QAction(ico_mail, "Email",    self)
        a_tg.triggered.connect(lambda: self.share_text_telegram_appfirst(text))
        a_wa.triggered.connect(lambda: self.share_text_whatsapp(text))
        a_mail.triggered.connect(lambda: self._share_email(f"Ð”Ð°Ð½Ð½Ñ‹Ðµ: {block.get('title','')}", text, None))
        m.addAction(a_tg); m.addAction(a_wa); m.addAction(a_mail)
        m.exec(QCursor.pos())
    def safe_open_block_editor(self, block):
        ref = self.id_to_ref.get(block.get("id","")); key = ref[0] if ref else ""
        path_list = [p for p in key.split("/") if p]
        if not self.ensure_chain_unlocked(path_list):
            return
        prev_show = self.show_data
        try:
            if not self.show_data:
                self.show_data = True
                if hasattr(self, "btn_toggle_data"):
                    self.btn_toggle_data.setChecked(True)
                    self.btn_toggle_data.setText("Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
            BlockEditorDialog(self, block).exec()
        except Exception as e:
            custom_warning(self, "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
        finally:
            if not prev_show:
                self.show_data = False
                if hasattr(self, "btn_toggle_data"):
                    self.btn_toggle_data.setChecked(False)
                    self.btn_toggle_data.setText("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
            self.schedule_render()
    def on_blocks_dropped_to_section(self, target_path, block_ids):
        for bid in block_ids:
            ref = self.id_to_ref.get(bid)
            if not ref: continue
            from_key, block = ref
            if from_key == target_path: continue
            self.blocks_data.setdefault(target_path, []).append(block)
            self.blocks_data[from_key] = [b for b in self.blocks_data[from_key] if b is not block]
            if not self.blocks_data[from_key]: del self.blocks_data[from_key]
            block["category"] = target_path.split("/")[-1] if target_path else block.get("category","")
            self.id_to_ref[bid] = (target_path, block)
            self.update_index_for_block(block)
            audit_write("move_block", {"block_id": bid, "from": from_key, "to": target_path})
        self.save_blocks()
        self.schedule_render()
    def add_block(self):
        key = self.current_key()
        if not key:
            custom_warning(self, "Ð’Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ", "Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð´ÐµÐ».")
            return
        title, ok = QInputDialog.getText(self, "ÐÐ¾Ð²Ñ‹Ð¹ Ð±Ð»Ð¾Ðº", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°:")
        if not (ok and title): return
        block = {"id": secrets.token_hex(12), "title": title.strip(), "category": key.split("/")[-1], "fields": {}, "icon": ""}
        choices = ["(Ð±ÐµÐ· ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°)", "Ð£Ñ‡Ñ‘Ñ‚ÐºÐ° (URL, Ð›Ð¾Ð³Ð¸Ð½, ÐŸÐ°Ñ€Ð¾Ð»ÑŒ)", "Ð‘Ð°Ð½Ðº (ÐÐ¾Ð¼ÐµÑ€ ÐºÐ°Ñ€Ñ‚Ñ‹, Ð¡Ñ€Ð¾Ðº, CVC)"]
        user_tpls = self.meta.get("templates") or []
        choices += [f"Ð¨Ð°Ð±Ð»Ð¾Ð½: {t['name']}" for t in user_tpls]
        sel, ok2 = QInputDialog.getItem(self, "Ð¨Ð°Ð±Ð»Ð¾Ð½", "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑˆÐ°Ð±Ð»Ð¾Ð½:", choices, 0, False)
        if ok2 and sel and sel != "(Ð±ÐµÐ· ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°)":
            if sel.startswith("Ð¨Ð°Ð±Ð»Ð¾Ð½: "):
                name = sel.split(": ",1)[1]
                t = next((x for x in user_tpls if x["name"] == name), None)
                if t:
                    for f in t.get("fields", []):
                        block["fields"][f] = encrypt_value("", self.fernet)
            elif sel.startswith("Ð£Ñ‡Ñ‘Ñ‚ÐºÐ°"):
                for f in ("URL", "Ð›Ð¾Ð³Ð¸Ð½", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ"):
                    block["fields"][f] = encrypt_value("", self.fernet)
            elif sel.startswith("Ð‘Ð°Ð½Ðº"):
                for f in ("ÐÐ¾Ð¼ÐµÑ€ ÐºÐ°Ñ€Ñ‚Ñ‹", "Ð¡Ñ€Ð¾Ðº", "CVC"):
                    block["fields"][f] = encrypt_value("", self.fernet)
        self.blocks_data.setdefault(key, []).append(block)
        self.id_to_ref[block["id"]] = (key, block)
        self.update_index_for_block(block)
        self.save_blocks()
        self.schedule_render()
        audit_write("add_block", {"key": key, "block_id": block["id"], "title": block["title"]})
    def move_block_dialog(self, block):
        paths = self.get_all_paths()
        target, ok = QInputDialog.getItem(self, "ÐŸÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ð±Ð»Ð¾Ðº", "Ð Ð°Ð·Ð´ÐµÐ»:", paths, 0, True)
        if not (ok and target): return
        self.move_block(block, target)
    def move_block(self, block, target):
        old_key, _ = self.id_to_ref.get(block["id"], (None, None))
        if not old_key: return
        self.blocks_data.setdefault(target, []).append(block)
        self.blocks_data[old_key] = [b for b in self.blocks_data[old_key] if b is not block]
        if not self.blocks_data[old_key]:
            del self.blocks_data[old_key]
        block["category"] = target.split("/")[-1] if target else block.get("category", "")
        self.id_to_ref[block["id"]] = (target, block)
        self.update_index_for_block(block)
        self.save_blocks()
        self.schedule_render()
        audit_write("move_block", {"block_id": block["id"], "from": old_key, "to": target})
    def delete_block_soft(self, block):
        key, _ = self.id_to_ref.get(block["id"], (None, None))
        if not key:
            return
        if not custom_question(self, "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð±Ð»Ð¾Ðº?",
                               f"Ð‘Ð»Ð¾Ðº Â«{block.get('title','(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)')}Â» Ð±ÑƒÐ´ÐµÑ‚ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰Ñ‘Ð½ Ð² ÐšÐ¾Ñ€Ð·Ð¸Ð½Ñƒ. ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ?"):
            return
        self.blocks_data[key] = [b for b in self.blocks_data[key] if b is not block]
        if not self.blocks_data[key]:
            del self.blocks_data[key]
        self.trash.append({
            "id": block["id"],
            "from_key": key,
            "block": block,
            "ts": datetime.utcnow().isoformat() + "Z"
        })
        self.remove_index_for_block(block)
        self.save_blocks()
        self.save_trash()
        self.schedule_render()
        audit_write("trash_move", {"block_id": block["id"], "from": key})
    def restore_from_trash(self):
        if not self.trash:
            custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð° Ð¿ÑƒÑÑ‚Ð°.")
            return
        items = []
        for t in self.trash:
            b = t.get("block", {})
            title = b.get("title", "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)")
            frm = t.get("from_key", "")
            ts = t.get("ts", "")
            short = t.get("id", "")[:6]
            items.append(f"{title} â€” Ð¸Ð· {frm} â€” {ts} â€” {short}")
        sel, ok = QInputDialog.getItem(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ", "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð±Ð»Ð¾Ðº:", items, 0, False)
        if not (ok and sel):
            return
        idx = items.index(sel)
        it = self.trash[idx]
        key = it.get("from_key", "")
        b = it["block"]
        if key:
            self._ensure_tree_path(key)
            self.save_tree()
            self.render_tree()
        self.blocks_data.setdefault(key, []).append(b)
        self.id_to_ref[b["id"]] = (key, b)
        self.update_index_for_block(b)
        self.trash.remove(it)
        self.save_blocks()
        self.save_trash()
        self.current_path = [p for p in key.split("/") if p]
        self.schedule_render()
        audit_write("trash_restore", {"block_id": b["id"], "to": key})
    def clear_trash(self):
        if not self.trash:
            custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð° ÑƒÐ¶Ðµ Ð¿ÑƒÑÑ‚Ð°.")
            return
        if not custom_question(self, "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ",
                               "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð¸Ð· ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñ‹ Ð±ÐµÐ·Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚Ð½Ð¾?"):
            return
        if not self.verify_master_prompt("ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ¸", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ¸ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñ‹:"):
            return
        cnt = len(self.trash)
        self.trash.clear()
        self.save_trash()
        custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", f"Ð£Ð´Ð°Ð»ÐµÐ½Ð¾: {cnt}")
        audit_write("trash_clear", {"count": cnt})
    def on_block_changed(self, block, meta=None):
        for k, v in list(block.get("fields", {}).items()):
            plain, ok = self._try_decrypt_once(v)
            if ok:
                block["fields"][k] = encrypt_value(plain, self.fernet)
            else:
                block["fields"][k] = v
        self.update_index_for_block(block)
        self.save_blocks()
        audit_write("block_changed", {"block_id": block["id"], **(meta or {})})
    def toggle_data(self):
        want = self.btn_toggle_data.isChecked()
        if want:
            path = self.current_path or []
            if not self.ensure_chain_unlocked(path):
                self.btn_toggle_data.setChecked(False)
                return
        self.show_data = want
        self.btn_toggle_data.setText("Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ" if self.show_data else "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
        self.schedule_render()
    def open_url_safe(self, url: QUrl, title: str = "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÑÑÑ‹Ð»ÐºÑƒ"):
        try:
            ok = QDesktopServices.openUrl(url)
            if not ok:
                custom_warning(self, title, "Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð¾Ñ‚ÐºÐ»Ð¾Ð½Ð¸Ð»Ð° Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ ÑÑÑ‹Ð»ÐºÐ¸.")
        except Exception as e:
            custom_error(self, title, f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ñ ÑÑÑ‹Ð»ÐºÐ¸:\n{e}")
    def share_text_telegram(self, text: str) -> None:
        try:
            text = (text or "(Ð¿ÑƒÑÑ‚Ð¾)").replace("\r\n", "\n")
            first_url = None
            try:
                tokens = re.split(r"\s+", text)
                for tok in tokens:
                    if is_url(tok):
                        first_url = tok if tok.lower().startswith(("http://", "https://")) else ("https://" + tok)
                        break
            except Exception:
                first_url = None
            u = QUrl("https://t.me/share/url")
            q = QUrlQuery()
            if first_url:
                q.addQueryItem("url", first_url)
                rest = text.replace(first_url, "", 1).strip()
                if rest:
                    q.addQueryItem("text", rest)
            else:
                q.addQueryItem("text", text)
            u.setQuery(q)
            try:
                self.open_url_safe(u, "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² Telegram")
                self.archive_share_text_encrypted(text)
                return
            except Exception:
                pass
            MAX_DEEPLINK = 2000
            if len(text) <= MAX_DEEPLINK:
                for scheme in ("tg://share", "tg://msg", "tg://msg_url"):
                    u2 = QUrl(scheme)
                    q2 = QUrlQuery()
                    q2.addQueryItem("text", text)
                    u2.setQuery(q2)
                    try:
                        if QDesktopServices.openUrl(u2):
                            self.archive_share_text_encrypted(text)
                            return
                    except Exception:
                        pass
            try:
                tmp_txt = self.write_temp_text_for_send(text)
                self.archive_share_text_encrypted(text)
                self.share_files_telegram([tmp_txt])
                return
            except Exception:
                pass
            QApplication.clipboard().setText(text)
            custom_info(self, "Telegram", "Ð¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.\nÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Telegram Ð¸ Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ (Ctrl+V).")
            self.open_url_safe(QUrl("tg://"), "Telegram")
        except Exception as e:
            QApplication.clipboard().setText(text or "")
            custom_warning(self, "Telegram", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Telegram: {e}\nÐ¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.")
    def share_text_telegram_appfirst(self, text: str) -> None:
        try:
            text = (text or "(Ð¿ÑƒÑÑ‚Ð¾)").replace("\r\n", "\n")
            try:
                tmp_txt = self.write_temp_text_for_send(text)
                self.archive_share_text_encrypted(text)
                self.share_files_telegram([tmp_txt])
                return
            except Exception:
                pass
            MAX_DEEPLINK = 2000
            if len(text) <= MAX_DEEPLINK:
                for scheme in ("tg://share", "tg://msg", "tg://msg_url"):
                    u = QUrl(scheme)
                    q = QUrlQuery()
                    q.addQueryItem("text", text)
                    u.setQuery(q)
                    try:
                        if QDesktopServices.openUrl(u):
                            self.archive_share_text_encrypted(text)
                            return
                    except Exception:
                        pass
            try:
                u = QUrl("https://t.me/share/url")
                q = QUrlQuery()
                q.addQueryItem("text", text)
                u.setQuery(q)
                self.open_url_safe(u, "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð² Telegram")
                self.archive_share_text_encrypted(text)
                return
            except Exception:
                pass
            QApplication.clipboard().setText(text)
            custom_info(self, "Telegram", "Ð¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.\nÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Telegram Ð¸ Ð²ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ (Ctrl+V).")
            self.open_url_safe(QUrl("tg://"), "Telegram")
        except Exception as e:
            QApplication.clipboard().setText(text or "")
            custom_warning(self, "Telegram", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Telegram: {e}\nÐ¢ÐµÐºÑÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°.")
    def change_master_password(self):
        p1 = self.ask_password("ÐÐ¾Ð²Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ:")
        if p1 is None:
            return
        if len(p1) < 6:
            custom_warning(self, "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ", "ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð°Ñ Ð´Ð»Ð¸Ð½Ð° â€” 6 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð².")
            return
        p2 = self.ask_password("ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ", "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ:")
        if p2 is None or p1 != p2:
            custom_warning(self, "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ", "ÐŸÐ°Ñ€Ð¾Ð»Ð¸ Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑŽÑ‚.")
            return
        try:
            old_fernet = self.fernet
            new_key_salt = rand_bytes(16)
            new_auth_salt = rand_bytes(16)
            new_fernet = make_fernet(p1, new_key_salt,
                         kdf_name=self.kdf_name, params=self.kdf_params)
            for arr in self.blocks_data.values():
                for b in arr:
                    for kf, vf in list(b.get("fields", {}).items()):
                        plain = decrypt_value(vf, old_fernet)
                        b["fields"][kf] = new_fernet.encrypt(plain.encode("utf-8")).decode("utf-8")
            for bid in os.listdir(ATTACH_DIR):
                d = os.path.join(ATTACH_DIR, bid)
                if not os.path.isdir(d):
                    continue
                for fn in os.listdir(d):
                    fp = os.path.join(d, fn)
                    if fn.endswith(".meta.json"):
                        try:
                            mj = secure_read_json(fp, old_fernet, {})
                            secure_write_json(fp, mj, new_fernet)
                        except Exception:
                            pass
                        continue
                    try:
                        with open(fp, "rb") as f:
                            enc = f.read()
                        data = old_fernet.decrypt(enc)
                        new_enc = new_fernet.encrypt(data)
                        with open(fp, "wb") as w:
                            w.write(new_enc)
                    except Exception:
                        pass
            self.master = p1
            self.key_salt, self.auth_salt = new_key_salt, new_auth_salt
            self.fernet = new_fernet
            write_auth_file(new_key_salt, new_auth_salt,
                hash_for_auth(p1, new_auth_salt,
                              prefer_argon=(self.kdf_name == "argon2id"),
                              params=self.kdf_params),
                self.kdf_name, self.kdf_params)
            self.ensure_verifier_current()
            self.save_blocks()
            self.save_tree()
            self.save_meta()
            self.save_trash()
            custom_info(self, "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ", "ÐœÐ°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¸Ð·Ð¼ÐµÐ½Ñ‘Ð½. Ð’ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿ÐµÑ€Ðµ-ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ñ‹.")
            audit_write("master_changed", {})
        except Exception as e:
            custom_error(self, "ÐžÑˆÐ¸Ð±ÐºÐ°", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ:\n{e}\n\n{traceback.format_exc()}")
    def migrate_kdf_params(self, new_params: dict, kdf_name: str = "argon2id") -> None:
        if not self.verify_master_prompt("ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ ÑÐ¼ÐµÐ½Ñ‹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² KDF:"):
            return
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            old_fernet = self.fernet
            new_fernet = make_fernet(self.master, self.key_salt, kdf_name=kdf_name, params=new_params)
            for arr in self.blocks_data.values():
                for b in arr:
                    for kf, vf in list(b.get("fields", {}).items()):
                        plain = decrypt_value(vf, old_fernet)
                        b["fields"][kf] = new_fernet.encrypt(plain.encode("utf-8")).decode("utf-8")
                    nplain = decrypt_value(b.get("notes", ""), old_fernet)
                    b["notes"] = new_fernet.encrypt(nplain.encode("utf-8")).decode("utf-8")
            for bid in os.listdir(ATTACH_DIR):
                d = os.path.join(ATTACH_DIR, bid)
                if not os.path.isdir(d): 
                    continue
                for fn in os.listdir(d):
                    fp = os.path.join(d, fn)
                    if fn.endswith(".meta.json"):
                        try:
                            mj = secure_read_json(fp, old_fernet, {})
                            secure_write_json(fp, mj, new_fernet)
                        except Exception:
                            pass
                        continue
                    try:
                        with open(fp, "rb") as f:
                            enc = f.read()
                        data = old_fernet.decrypt(enc)
                        new_enc = new_fernet.encrypt(data)
                        with open(fp, "wb") as w:
                            w.write(new_enc)
                    except Exception:
                        pass
            self.fernet = new_fernet
            self.kdf_name = kdf_name
            self.kdf_params = dict(new_params)
            write_auth_file(
                self.key_salt, self.auth_salt,
                hash_for_auth(self.master, self.auth_salt, prefer_argon=(kdf_name == "argon2id"), params=self.kdf_params),
                self.kdf_name, self.kdf_params
            )
            self.ensure_verifier_current()
            self.save_blocks(); self.save_tree(); self.save_meta(); self.save_trash()
            try:
                self.index.fernet = new_fernet
                self.index.save()
            except Exception:
                pass
            custom_info(self, "KDF", "ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ KDF Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹.")
        finally:
            QApplication.restoreOverrideCursor()
    def export_section(self, item):
        path = []
        cur = item
        while cur and cur.text(0) != "ðŸ§  Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸":
            path.insert(0, cur.text(0))
            cur = cur.parent()
        key = "/".join(path)
        self.export_by_key(key)
    def export_by_key(self, key):
        rows = []
        all_fieldnames = set()
        def push_block(k, b):
            parts = k.split("/")
            row = {
                "Ð Ð°Ð·Ð´ÐµÐ»": parts[0] if len(parts) > 0 else "",
                "ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»": parts[1] if len(parts) > 1 else "",
                "ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»": parts[2] if len(parts) > 2 else "",
                "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°": b.get("title", "")
            }
            for kf, vf in b.get("fields", {}).items():
                row[kf] = decrypt_value(vf, self.fernet)
                all_fieldnames.add(kf)
            rows.append(row)
        pref = key + "/" if key else ""
        for k, arr in self.blocks_data.items():
            if k == key or k.startswith(pref):
                for b in arr:
                    push_block(k, b)
        cols = ["Ð Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°"] + sorted(all_fieldnames)
        self._export_rows(rows, cols, title="Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°")
        audit_write("export_section", {"key": key, "rows": len(rows)})
    def export_all(self):
        rows = []
        all_fieldnames = set()
        def push_block(k, b):
            parts = k.split("/")
            row = {
                "Ð Ð°Ð·Ð´ÐµÐ»": parts[0] if len(parts) > 0 else "",
                "ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»": parts[1] if len(parts) > 1 else "",
                "ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»": parts[2] if len(parts) > 2 else "",
                "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°": b.get("title", "")
            }
            for kf, vf in b.get("fields", {}).items():
                row[kf] = decrypt_value(vf, self.fernet)
                all_fieldnames.add(kf)
            rows.append(row)
        for k, arr in self.blocks_data.items():
            for b in arr:
                push_block(k, b)
        cols = ["Ð Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐŸÐ¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°"] + sorted(all_fieldnames)
        self._export_rows(rows, cols, title="Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð²ÑÐµÐ³Ð¾")
        audit_write("export_all", {"rows": len(rows)})
    def _export_rows(self, rows, cols, title="Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚"):
        if not rows:
            custom_info(self, title, "ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°.")
            return
        path, _ = QFileDialog.getSaveFileName(
            self, title, "",
            "Excel (*.xlsx);;CSV (*.csv);;JSON (*.json);;Text (*.txt);;HTML (*.html)"
        )
        if not path:
            return
        try:
            df = pd.DataFrame(rows, columns=cols)
            if path.endswith(".xlsx"):
                df.to_excel(path, index=False)
            elif path.endswith(".csv"):
                with open(path, "w", newline="", encoding="utf-8-sig") as f:
                    writer = csv.writer(f)
                    writer.writerow(cols)
                    for r in rows:
                        writer.writerow([r.get(c, "") for c in cols])
            elif path.endswith(".json"):
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(rows, f, ensure_ascii=False, indent=2)
            elif path.endswith(".txt"):
                with open(path, "w", encoding="utf-8") as f:
                    f.write("|".join(cols) + "\n")
                    for r in rows:
                        f.write("|".join(str(r.get(c, "")) for c in cols) + "\n")
            elif path.endswith(".html"):
                with open(path, "w", encoding="utf-8") as f:
                    f.write("<html><body><h2>LinkPass Export</h2><table border=1><tr>")
                    for c in cols:
                        f.write(f"<th>{c}</th>")
                    f.write("</tr>")
                    for r in rows:
                        f.write("<tr>")
                        for c in cols:
                            f.write(f"<td>{r.get(c,'')}</td>")
                        f.write("</tr>")
                    f.write("</table></body></html>")
            custom_info(self, title, "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!")
        except Exception as e:
            custom_error(self, title, f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°: {e}")
    def _norm_cell(self, v: object) -> str:
        if v is None:
            return ""
        s = str(v).replace("\ufeff", "").strip()
        if s.lower() in ("nan", "none", "null"):
            return ""
        return s
    def _find_first_present(self, candidates: list[str], columns: list[str]) -> str | None:
        norm_map = { self._norm_cell(c).lower(): c for c in columns }
        for cand in candidates:
            key = self._norm_cell(cand).lower()
            if key in norm_map:
                return norm_map[key]
        return None
    def _section_columns_in_order(self, columns: list[str]) -> list[str]:
        def n(s: str) -> str:
            return self._norm_cell(s)
        exact: list[tuple[int, str]] = []
        numbered: list[tuple[int, str]] = []
        for c in columns:
            nc = n(c).lower()
            if nc == "Ñ€Ð°Ð·Ð´ÐµÐ»" or nc == "section":
                exact.append((0, c))
            elif nc == "Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»" or nc == "subsection":
                exact.append((1, c))
            elif nc == "Ð¿Ð¾Ð´Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»" or nc in ("subsubsection", "sub-subsection"):
                exact.append((2, c))
            else:
                m = re.fullmatch(r"(?:Ñ€Ð°Ð·Ð´ÐµÐ»|section)\s*(\d+)", nc, flags=re.IGNORECASE)
                if m:
                    try:
                        numbered.append((3 + int(m.group(1)), c))
                    except Exception:
                        pass
        exact.sort(key=lambda t: t[0])
        numbered.sort(key=lambda t: t[0])
        return [c for _, c in exact] + [c for _, c in numbered]
    def _detect_path_col(self, columns: list[str]) -> str | None:
        return self._find_first_present([
            "ÐŸÑƒÑ‚ÑŒ",
            "Path",
            "SectionPath",
            "Section Path",
            "ÐŸÑƒÑ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»Ð°",
            "ÐŸÑƒÑ‚ÑŒ Ðº Ñ€Ð°Ð·Ð´ÐµÐ»Ñƒ",
        ], columns)
    def import_data(self):
        path, _ = QFileDialog.getOpenFileName(
            self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…", "",
            "Excel (*.xlsx);;JSON (*.json);;CSV (*.csv);;Text (*.txt)"
        )
        if not path:
            return
        new_blocks: dict[str, list[dict]] = {}
        def push_block_by_parts(parts: list[str], row_fields: dict, title_val: str):
            parts_clean = [self._norm_cell(p) for p in parts if self._norm_cell(p)]
            key = "/".join(parts_clean) if parts_clean else "_"
            want_cat = parts_clean[-1] if parts_clean else ""
            block = {
                "id": secrets.token_hex(12),
                "title": title_val,
                "category": want_cat,
                "fields": {},
                "icon": ""
            }
            for kf, vf in row_fields.items():
                nv = self._norm_cell(vf)
                if nv != "":
                    block["fields"][kf] = encrypt_value(nv, self.fernet)
            if not block["fields"] and not block["title"] and not want_cat:
                return
            new_blocks.setdefault(key, []).append(block)
        try:
            if path.endswith(".xlsx"):
                df = pd.read_excel(path, dtype=str, engine="openpyxl")
                if df is None:
                    custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Excel.")
                    return
                df = df.fillna("")
                orig_cols = df.columns.tolist()
                title_col = self._find_first_present(
                    ["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ", "Title", "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº"], orig_cols
                )
                sect_cols = self._section_columns_in_order(orig_cols)
                path_col = self._detect_path_col(orig_cols)
                if path_col:
                    try:
                        ser = df[path_col].astype(str)
                        non_empty = ser[ser.str.strip() != ""]
                        frac = float((non_empty.str.contains("/")).mean()) if len(non_empty) else 0.0
                        if frac < 0.5:
                            path_col = None
                    except Exception:
                        path_col = None
                for rec in df.to_dict(orient="records"):
                    title_val = self._norm_cell(rec.get(title_col, "")) if title_col else ""
                    if path_col:
                        parts = [p.strip() for p in str(rec.get(path_col, "")).split("/") if p and p.strip()]
                    else:
                        parts = [self._norm_cell(rec.get(c, "")) for c in sect_cols]
                    row_fields = {}
                    skip = set(sect_cols + ([title_col] if title_col else []) + ([path_col] if path_col else []) + ["ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ"])
                    for col in orig_cols:
                        if col in skip:
                            continue
                        val = self._norm_cell(rec.get(col, ""))
                        if val != "":
                            row_fields[col] = val
                    push_block_by_parts(parts, row_fields, title_val)
            elif path.endswith(".json"):
                with open(path, "r", encoding="utf-8") as f:
                    loaded = json.load(f)
                def encrypt_or_passthrough(val):
                    plain, ok = self._try_decrypt_once(val)
                    if ok:
                        return encrypt_value(self._norm_cell(plain), self.fernet)
                    if isinstance(val, str) and val.startswith("gAAAA"):
                        return val
                    return encrypt_value(self._norm_cell(str(val)), self.fernet)
                if isinstance(loaded, dict):
                    for k, arr in loaded.items():
                        if not isinstance(arr, list):
                            continue
                        k_str = "" if k is None else str(k)
                        parts = [p.strip() for p in k_str.split("/") if p and p.strip()]
                        key = "/".join(parts) if parts else "_"
                        for b in arr:
                            if not isinstance(b, dict):
                                continue
                            bid = b.get("id") or secrets.token_hex(12)
                            title_val = self._norm_cell(b.get("title", ""))
                            cat = self._norm_cell(b.get("category", "")) or (key.split("/")[-1] if key and key != "_" else "")
                            fields = {}
                            for fk, fv in (b.get("fields", {}) or {}).items():
                                nv = self._norm_cell(self._try_decrypt_once(fv)[0] if isinstance(fv, str) else str(fv))
                                if nv != "":
                                    fields[fk] = encrypt_or_passthrough(fv)
                            block = {"id": bid, "title": title_val, "category": cat, "fields": fields, "icon": ""}
                            if fields or title_val or cat:
                                new_blocks.setdefault(key, []).append(block)
                elif isinstance(loaded, list):
                    all_cols: list[str] = []
                    for r in loaded:
                        if isinstance(r, dict):
                            for k in r.keys():
                                if k not in all_cols:
                                    all_cols.append(k)
                    title_col = self._find_first_present(["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ", "Title", "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº"], all_cols)
                    sect_cols = self._section_columns_in_order(all_cols)
                    path_col = self._detect_path_col(all_cols)
                    if path_col:
                        vals = [str(r.get(path_col, "")).strip() for r in loaded if isinstance(r, dict)]
                        nz = [v for v in vals if v]
                        if not nz or (sum(1 for v in nz if "/" in v) / len(nz) < 0.5):
                            path_col = None
                    for r in loaded:
                        if not isinstance(r, dict):
                            continue
                        if path_col:
                            parts = [p.strip() for p in str(r.get(path_col, "")).split("/") if p and p.strip()]
                        else:
                            parts = [self._norm_cell(r.get(c, "")) for c in sect_cols]
                        title_val = self._norm_cell(r.get(title_col, "")) if title_col else ""
                        fields = {}
                        skip = set(sect_cols + ([title_col] if title_col else []) + ([path_col] if path_col else []) + ["ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ"])
                        for kcol in all_cols:
                            if kcol in skip:
                                continue
                            raw = r.get(kcol, "")
                            if self._norm_cell(raw) == "":
                                continue
                            fields[kcol] = encrypt_or_passthrough(raw)
                        push_block_by_parts(parts, fields, title_val)
                else:
                    custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "ÐÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ð°Ñ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° JSON.")
                    return
            elif path.endswith(".csv"):
                def read_csv_auto(enc: str):
                    with open(path, newline="", encoding=enc) as f:
                        sample = f.read(8192)
                        f.seek(0)
                        try:
                            dialect = csv.Sniffer().sniff(sample, delimiters=",;\t|")
                            reader = csv.DictReader(f, dialect=dialect)
                        except Exception:
                            counts: dict[str, int] = {
                                ",": sample.count(","),
                                ";": sample.count(";"),
                                "\t": sample.count("\t"),
                                "|": sample.count("|"),
                            }
                            delim: str = max(counts.keys(), key=lambda k: counts[k])
                            reader = csv.DictReader(f, delimiter=delim)
                        return list(reader)
                try:
                    rows = read_csv_auto("utf-8-sig")
                except UnicodeDecodeError:
                    rows = read_csv_auto("cp1251")
                if not rows:
                    custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "CSV Ð¿ÑƒÑÑ‚Ð¾Ð¹ Ð¸Ð»Ð¸ Ð±ÐµÐ· Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¾Ð².")
                    return
                orig_columns = list(rows[0].keys())
                title_col = self._find_first_present(
                    ["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ", "Title", "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº"], orig_columns
                )
                sect_cols = self._section_columns_in_order(orig_columns)
                path_col = self._detect_path_col(orig_columns)
                if path_col:
                    vals = [str(row.get(path_col, "")).strip() for row in rows]
                    nz = [v for v in vals if v]
                    if not nz or (sum(1 for v in nz if "/" in v) / len(nz) < 0.5):
                        path_col = None
                for row in rows:
                    if path_col:
                        raw_path = str(row.get(path_col, "")).strip()
                        parts = [p for p in raw_path.split("/") if p]
                    else:
                        parts = [self._norm_cell(row.get(c, "")) for c in sect_cols]
                    title_val = self._norm_cell(row.get(title_col, "")) if title_col else ""
                    row_fields: dict[str, str] = {}
                    skip = set(sect_cols + ([title_col] if title_col else []) + ([path_col] if path_col else []) + ["ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ"])
                    for col in orig_columns:
                        if col in skip:
                            continue
                        val = self._norm_cell(row.get(col, ""))
                        if val != "":
                            row_fields[col] = val
                    push_block_by_parts(parts, row_fields, title_val)
            elif path.endswith(".txt"):
                def read_txt_try(enc: str):
                    with open(path, "r", encoding=enc) as f:
                        return f.read().splitlines()
                try:
                    lines = read_txt_try("utf-8-sig")
                except UnicodeDecodeError:
                    lines = read_txt_try("cp1251")
                if not lines:
                    custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "TXT Ð¿ÑƒÑÑ‚Ð¾Ð¹.")
                    return
                header = [self._norm_cell(c) for c in lines[0].split("|")]
                title_col = self._find_first_present(
                    ["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ°", "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ", "Title", "Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº"], header
                )
                sect_cols = self._section_columns_in_order(header)
                path_col = self._detect_path_col(header)
                if path_col:
                    non_empty = 0
                    with_slash = 0
                    try:
                        idx = header.index(path_col)
                    except ValueError:
                        idx = -1
                    if idx >= 0:
                        for line in lines[1:]:
                            if not line.strip():
                                continue
                            parts_line = line.split("|")
                            val = parts_line[idx].strip() if idx < len(parts_line) else ""
                            if val:
                                non_empty += 1
                                if "/" in val:
                                    with_slash += 1
                        if non_empty == 0 or (with_slash / non_empty) < 0.5:
                            path_col = None
                    else:
                        path_col = None
                for line in lines[1:]:
                    if not line.strip():
                        continue
                    parts_line = line.split("|")
                    row = {header[i]: (parts_line[i] if i < len(parts_line) else "") for i in range(len(header))}
                    if path_col:
                        raw_path = str(row.get(path_col, "")).strip()
                        parts = [p for p in raw_path.split("/") if p]
                    else:
                        parts = [self._norm_cell(row.get(c, "")) for c in sect_cols]
                    title_val = self._norm_cell(row.get(title_col, "")) if title_col else ""
                    row_fields: dict[str, str] = {}
                    skip = set(sect_cols + ([title_col] if title_col else []) + ([path_col] if path_col else []) + ["ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ"])
                    for col in header:
                        if col in skip:
                            continue
                        val = self._norm_cell(row.get(col, ""))
                        if val != "":
                            row_fields[col] = val
                    push_block_by_parts(parts, row_fields, title_val)
            else:
                custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", "ÐÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ñ„Ð°Ð¹Ð»Ð°.")
                return
        except Exception as e:
            custom_warning(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð°: {e}")
            return
        for k in new_blocks.keys():
            if k and k != "_":
                self._ensure_tree_path(k)
        added = 0
        for k, arr in new_blocks.items():
            self.blocks_data.setdefault(k, []).extend(arr)
            for b in arr:
                self.id_to_ref[b["id"]] = (k, b)
                self.update_index_for_block(b)
            added += len(arr)
        self.save_tree()
        self.save_blocks()
        self.render_tree()
        self.schedule_render()
        audit_write("import", {"file": path, "sections": len(new_blocks), "blocks": added})
        custom_info(self, "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚", f"Ð“Ð¾Ñ‚Ð¾Ð²Ð¾. Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð±Ð»Ð¾ÐºÐ¾Ð²: {added}.")
    def restore_backup_unified(self):
        path, _ = QFileDialog.getOpenFileName(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ", "", "LPX/LPBK/LPEX/ZIP (*.lpx *.lpbk *.lpex *.zip)")
        if not path: return
        pwd = None
        if not path.lower().endswith(".zip"):
            pwd = self.ask_password("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ñ„Ð°Ð¹Ð»Ð°", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ:")
            if pwd is None:
                return
        def work():
            tmpdir = tempfile.mkdtemp(prefix="LinkPass_restore_")
            if path.lower().endswith(".zip"):
                with zipfile.ZipFile(path, "r") as z:
                    z.extractall(tmpdir)
            else:
                raw = _lpx_decrypt_bytes_or_file(path, pwd or "")
                with zipfile.ZipFile(io.BytesIO(raw), "r") as z:
                    z.extractall(tmpdir)
            return tmpdir
        def done(tmpdir):
            try:
                if not custom_question(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ", "ÐŸÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°?\n(Ð±ÑƒÐ´ÐµÑ‚ ÑÐ¾Ð·Ð´Ð°Ð½Ð° ÐºÐ¾Ð¿Ð¸Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ)"):
                    shutil.rmtree(tmpdir, ignore_errors=True); return
                self._copy_restored(tmpdir)
                shutil.rmtree(tmpdir, ignore_errors=True)
                self._reload_all_from_disk_after_restore()
                restored_blocks = 0
                try:
                    restored_blocks = sum(len(arr) for arr in self.blocks_data.values())
                except Exception:
                    pass
                custom_info(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾", f"Ð“Ð¾Ñ‚Ð¾Ð²Ð¾. Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ð±Ð»Ð¾ÐºÐ¾Ð²: {restored_blocks}.")
                audit_write("restore_unified", {"file": path, "restored_blocks": restored_blocks})
            except Exception as e:
                shutil.rmtree(tmpdir, ignore_errors=True)
                custom_error(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
        run_long_task(self, "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ", work, done)
    def _copy_restored(self, srcdir):
        bdir = os.path.join(DATA_DIR, "_backup_before_restore_" + datetime.now().strftime("%Y%m%d-%H%M%S"))
        os.makedirs(bdir, exist_ok=True)
        for fn in (TREE_FILE, BLOCKS_FILE, TRASH_FILE, META_FILE, MASTER_FILE, INDEX_DB):
            if os.path.exists(fn):
                shutil.copy2(fn, os.path.join(bdir, os.path.basename(fn)))
        if os.path.isdir(ATTACH_DIR):
            shutil.copytree(ATTACH_DIR, os.path.join(bdir, "attachments"), dirs_exist_ok=True)
        for base in ("tree.json", "blocks.json", "trash.json", "meta.json", "auth.json", "index.db"):
            fp = os.path.join(srcdir, base)
            if os.path.exists(fp):
                shutil.copy2(fp, os.path.join(DATA_DIR, base))
        src_att = os.path.join(srcdir, "attachments")
        if os.path.isdir(src_att):
            shutil.copytree(src_att, ATTACH_DIR, dirs_exist_ok=True)
    def _reload_all_from_disk_after_restore(self) -> None:
        try:
            if os.path.exists(MASTER_FILE):
                with open(MASTER_FILE, "r", encoding="utf-8") as f:
                    j = json.load(f)
                new_key_salt = base64.b64decode(j.get("key_salt", "")) if j.get("key_salt") else self.key_salt
                new_auth_salt = base64.b64decode(j.get("auth_salt", "")) if j.get("auth_salt") else self.auth_salt
                kdf = j.get("kdf", "argon2id")
                params = j.get("kdf_params") or KDF_DEFAULTS
                verifier = j.get("verifier", "")
                calc = hash_for_auth(self.master, new_auth_salt,
                                    prefer_argon=(kdf == "argon2id"), params=params)
                if verifier and calc != verifier:
                    pwd = self.ask_password("ÐœÐ°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð±ÑÐºÐ°Ð¿Ð°",
                                            "ÐŸÐ¾ÑÐ»Ðµ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð±ÑÐºÐ°Ð¿Ð° Ð¼Ð°ÑÑ‚ÐµÑ€-Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»ÑÑ.\n"
                                            "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ, Ñ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¼ ÑÐ¾Ð·Ð´Ð°Ð²Ð°Ð»ÑÑ Ð±ÑÐºÐ°Ð¿:")
                    if pwd:
                        calc2 = hash_for_auth(pwd, new_auth_salt,
                                            prefer_argon=(kdf == "argon2id"), params=params)
                        if calc2 == verifier:
                            self.master = pwd
                            self.key_salt, self.auth_salt = new_key_salt, new_auth_salt
                            self.kdf_name, self.kdf_params = kdf, params
                            self.fernet = make_fernet(self.master, self.key_salt,
                                                    kdf_name=self.kdf_name, params=self.kdf_params)
                        else:
                            custom_warning(self, "Ð‘ÑÐºÐ°Ð¿", "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ Ð½Ðµ Ð¿Ð¾Ð´Ð¾ÑˆÑ‘Ð». Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð±ÑƒÐ´ÑƒÑ‚ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ð±ÐµÐ· Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸.")
                else:
                    self.key_salt, self.auth_salt = new_key_salt, new_auth_salt
                    self.kdf_name, self.kdf_params = kdf, params
                    self.fernet = make_fernet(self.master, self.key_salt,
                                            kdf_name=self.kdf_name, params=self.kdf_params)
        except Exception as e:
            custom_warning(self, "Ð‘ÑÐºÐ°Ð¿", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑ‚ÐµÑ€-ÐºÐ»ÑŽÑ‡ Ð¸Ð· Ð±ÑÐºÐ°Ð¿Ð°: {e}")
        prev_path = list(self.current_path)
        self.meta = self.load_meta()
        self.data_tree = self.load_tree()
        self.blocks_data = self.load_blocks()
        self.trash = self.load_trash()
        self.run_startup_migrations()
        self.rebuild_index()
        self.render_tree()
        if prev_path:
            self._select_path_in_tree(prev_path)
        self.schedule_render()
        audit_write("hot_reload_after_restore", {"sections": len(self.get_all_paths())})
    def show_export_tasks(self):
        ExportTasksManager(self).exec()
    def calc_next_run(self, typ, every_min, at_time):
        now = datetime.now()
        if typ == "interval":
            return (now + timedelta(minutes=max(1, int(every_min)))).strftime("%Y-%m-%d %H:%M")
        try:
            hh, mm = (at_time or "02:00").split(":")
            t = now.replace(hour=int(hh), minute=int(mm), second=0, microsecond=0)
        except Exception:
            t = now.replace(hour=2, minute=0, second=0, microsecond=0)
        if t <= now:
            t += timedelta(days=1)
        return t.strftime("%Y-%m-%d %H:%M")
    def tick_scheduler(self):
        tasks = self.meta.get("export_tasks", [])
        if not tasks:
            return
        now = datetime.now()
        changed = False
        for t in tasks:
            nr = t.get("next_run")
            if not nr:
                t["next_run"] = self.calc_next_run(t.get("type", "interval"), int(t.get("every_min", 60)), t.get("at_time", "02:00"))
                changed = True
                continue
            try:
                ts = datetime.strptime(nr, "%Y-%m-%d %H:%M")
            except Exception:
                t["next_run"] = self.calc_next_run(t.get("type", "interval"), int(t.get("every_min", 60)), t.get("at_time", "02:00"))
                changed = True
                continue
            if now >= ts:
                self.run_export_task(t)
                t["next_run"] = self.calc_next_run(t.get("type", "interval"), int(t.get("every_min", 60)), t.get("at_time", "02:00"))
                changed = True
        if changed:
            self.save_meta()
    def run_export_task(self, t):
        try:
            path_dir = (t.get("path_dir") or "").strip()
            if not path_dir:
                legacy_path = (t.get("path") or "").strip()
                if legacy_path:
                    pd = os.path.dirname(legacy_path)
                    if pd:
                        path_dir = pd
            if not path_dir:
                path_dir = DATA_DIR
            try:
                os.makedirs(path_dir, exist_ok=True)
            except Exception:
                pass
            try:
                enc_pwd = decrypt_value(t.get("enc_pwd_enc", ""), self.fernet) if t.get("enc_pwd_enc") else ""
            except Exception:
                enc_pwd = ""
            if not enc_pwd:
                audit_write("export_task_skip_no_password", {"name": t.get("name", "")})
                return
            raw_zip = self._make_full_backup_zip_bytes()
            data = _lpx_encrypt_bytes(raw_zip, enc_pwd)
            seq = int(t.get("seq", 1))
            ts  = datetime.now().strftime("%Y%m%d-%H%M%S")
            fname = f"backup_{ts}_{seq:04d}.lpx"
            out_path = os.path.join(path_dir, fname)
            with open(out_path, "wb") as f:
                f.write(data)
            t["seq"] = seq + 1
            self.save_meta()
            audit_write("export_task_run", {"name": t.get("name", ""), "file": out_path})
        except Exception as e:
            audit_write("export_task_error", {"name": t.get("name", ""), "error": str(e)})
    def _tpl(self, s: str, task: dict, seq_for_preview: int | None = None) -> str:
        now = datetime.now()
        seq = int(task.get("seq", 1))
        if seq_for_preview is not None:
            seq = seq_for_preview
        ctx = {
            "ts": now.strftime("%Y%m%d-%H%M%S"),
            "date": now.strftime("%Y-%m-%d"),
            "time": now.strftime("%H-%M-%S"),
            "datetime": now.strftime("%Y-%m-%d_%H-%M-%S"),
            "name": task.get("name", ""),
            "scope": task.get("scope", ""),
            "preset": task.get("preset", ""),
            "seq": seq,
            "seq2": f"{seq:02d}",
            "seq3": f"{seq:03d}",
            "seq4": f"{seq:04d}",
        }
        try:
            return (s or "").format(**ctx)
        except Exception:
            return s or ""
    def _export_bytes(self, rows: list[dict], cols: list[str], ext: str) -> tuple[bytes, str, str]:
        ext = (ext or "").lower()
        base_name = "export"
        if ext == ".xlsx":
            buf = io.BytesIO()
            df = pd.DataFrame(rows, columns=cols)
            with pd.ExcelWriter(buf, engine="openpyxl") as w:
                df.to_excel(w, index=False)
            return buf.getvalue(), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", base_name + ext
        elif ext == ".csv":
            s = io.StringIO()
            wr = csv.writer(s, lineterminator="\n")
            wr.writerow(cols)
            for r in rows:
                wr.writerow([r.get(c, "") for c in cols])
            return ("\ufeff" + s.getvalue()).encode("utf-8"), "text/csv; charset=utf-8", base_name + ext
        elif ext == ".json":
            return json.dumps(rows, ensure_ascii=False, indent=2).encode("utf-8"), "application/json; charset=utf-8", base_name + ext
        elif ext == ".txt":
            lines = ["|".join(cols)]
            for r in rows:
                lines.append("|".join(str(r.get(c, "")) for c in cols))
            return "\n".join(lines).encode("utf-8"), "text/plain; charset=utf-8", base_name + ext
        elif ext == ".html":
            out = ["<html><body><table border=1><tr>"]
            out.extend(f"<th>{c}</th>" for c in cols)
            out.append("</tr>")
            for r in rows:
                out.append("<tr>")
                out.extend(f"<td>{r.get(c,'')}</td>" for c in cols)
                out.append("</tr>")
            out.append("</table></body></html>")
            return "".join(out).encode("utf-8"), "text/html; charset=utf-8", base_name + ext
        s = io.StringIO()
        wr = csv.writer(s, lineterminator="\n")
        wr.writerow(cols)
        for r in rows:
            wr.writerow([r.get(c, "") for c in cols])
        return ("\ufeff" + s.getvalue()).encode("utf-8"), "text/csv; charset=utf-8", base_name + ".csv"
    def _zip_single_file_bytes(self, filename: str, data: bytes) -> bytes:
        buf = io.BytesIO()
        with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as z:
            z.writestr(filename, data)
        return buf.getvalue()
    def _lpex_encrypt_bytes(self, raw: bytes, password: str) -> bytes:
        if not password:
            raise ValueError("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½")
        salt = rand_bytes(16)
        if HAS_ARGON2:
            key = argon2id_key(password, salt)
            tag = b"A"
        else:
            key = pbkdf2_key(password, salt)
            tag = b"P"
        f = Fernet(base64.urlsafe_b64encode(key))
        enc = f.encrypt(raw)
        return b"LPEX1" + tag + salt + enc
    def _lpex_decrypt_file_to_bytes(self, path: str, password: str) -> bytes:
        with open(path, "rb") as f:
            data = f.read()
        if not data.startswith(b"LPEX1"):
            raise ValueError("ÐÐµ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» (Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ‚ÑÑ LPEX1)")
        kdf_tag = data[5:6]
        salt = data[6:22]
        enc = data[22:]
        key = argon2id_key(password, salt) if (kdf_tag == b"A" and HAS_ARGON2) else pbkdf2_key(password, salt)
        f = Fernet(base64.urlsafe_b64encode(key))
        return f.decrypt(enc) 
    def decrypt_export_file_dialog(self):
        path, _ = QFileDialog.getOpenFileName(self, "Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚ (LPX1/LPEX1)", "", "LPX/LPEX (*.lpx *.lpex);;All Files (*)")
        if not path:
            return
        pwd = self.ask_password("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð´Ð»Ñ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸:")
        if pwd is None:
            return
        try:
            data = _lpx_decrypt_bytes_or_file(path, pwd)
            try:
                with zipfile.ZipFile(io.BytesIO(data), "r") as z:
                    names = z.namelist()
                    if not names:
                        raise zipfile.BadZipFile("ÐŸÑƒÑÑ‚Ð¾Ð¹ ZIP")
                    default = names[0]
                    save, _ = QFileDialog.getSaveFileName(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»", default)
                    if not save:
                        return
                    with z.open(default) as src, open(save, "wb") as out:
                        out.write(src.read())
            except zipfile.BadZipFile:
                save, _ = QFileDialog.getSaveFileName(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»", "export.bin")
                if not save:
                    return
                with open(save, "wb") as w:
                    w.write(data)
            custom_info(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾.")
        except InvalidToken:
            custom_error(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ.")
        except Exception as e:
            custom_error(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
    def manage_smart_folders(self):
        dlg = SmartFolderManager(self.meta.get("smart_folders", []))
        if dlg.exec() == QDialog.DialogCode.Accepted:
            self.meta["smart_folders"] = dlg.value()
            self.save_meta()
            self.render_tree()
    def manage_templates(self):
        dlg = TemplatesManager(self.meta.get("templates", []))
        if dlg.exec() == QDialog.DialogCode.Accepted:
            self.meta["templates"] = dlg.value()
            self.save_meta()
    def manage_export_presets(self):
        all_fields = set()
        for arr in self.blocks_data.values():
            for b in arr:
                all_fields.update(b.get("fields", {}).keys())
        dlg = ExportPresetsManager(self.meta.get("export_presets", []), sorted(all_fields))
        if dlg.exec() == QDialog.DialogCode.Accepted:
            self.meta["export_presets"] = dlg.value()
            self.save_meta()
    def save_all(self):
        self.save_tree()
        self.save_blocks()
        self.save_meta()
        custom_info(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾", "Ð’ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹.")
        audit_write("save_all", {})
    def auto_lock(self):
        self.show_data = False
        try:
            if hasattr(self, "btn_toggle_data") and self.btn_toggle_data is not None:
                self.btn_toggle_data.setChecked(False)
                self.btn_toggle_data.setText("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ")
        except Exception:
            pass
        QApplication.clipboard().clear()
        try:
            for p in list(self._temp_share_dirs):
                shutil.rmtree(p, ignore_errors=True)
                self._temp_share_dirs.discard(p)
        except Exception:
            pass
        self.schedule_render()
        audit_write("auto_lock", {})
    def show_block_qr(self, block: dict):
        if self.can_show_block_data(block):
            payload = self._build_qr_plaintext(block)
        else:
            payload = self._format_block_share_text(block, reveal=False)
        QRDialog(block.get("title", ""), payload, self).exec()
    def closeEvent(self, e):
        try:
            try:
                if hasattr(self, "scheduler"):
                    self.scheduler.stop()
            except Exception:
                pass
            try:
                if hasattr(self, "inact_timer"):
                    self.inact_timer.stop()
            except Exception:
                pass
            try:
                if hasattr(self, "tray") and self.tray is not None:
                    self.tray.hide()
                    self.tray.deleteLater()
            except Exception:
                pass
            try:
                self.save_all()
            except Exception:
                pass
            try:
                self.index.save()
            except Exception:
                pass
            try:
                self.index.conn.close()
            except Exception:
                pass
            try:
                for p in list(self._temp_share_dirs):
                    shutil.rmtree(p, ignore_errors=True)
                    self._temp_share_dirs.discard(p)
            except Exception:
                pass
        finally:
            super().closeEvent(e)
def custom_info(parent, title, text):
    QMessageBox.information(parent, title, text)
def custom_warning(parent, title, text):
    QMessageBox.warning(parent, title, text)
def custom_error(parent, title, text):
    QMessageBox.critical(parent, title, text)
def custom_question(parent, title, text) -> bool:
    res = QMessageBox.question(
        parent, title, text,
        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        QMessageBox.StandardButton.No
    )
    return res == QMessageBox.StandardButton.Yes
class SmartFolderDialog(QDialog):
    def __init__(self, sf=None):
        super().__init__()
        self.setWindowTitle("Ð£Ð¼Ð½Ð°Ñ Ð¿Ð°Ð¿ÐºÐ°")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.name = QLineEdit()
        self.query = QLineEdit()
        self.scope = QLineEdit()
        self.mode = QComboBox()
        self.mode.addItems(["ÐŸÐ¾Ð»Ñ", "Ð‘Ð»Ð¾ÐºÐ¸"])
        lay = QVBoxLayout(self)
        lay.addWidget(QLabel("Ð˜Ð¼Ñ:")); lay.addWidget(self.name)
        lay.addWidget(QLabel("Ð—Ð°Ð¿Ñ€Ð¾Ñ:")); lay.addWidget(self.query)
        lay.addWidget(QLabel("ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ñ‚ÑŒ Ñ€Ð°Ð·Ð´ÐµÐ»Ð¾Ð¼ (Ð¿ÑƒÑ‚ÑŒ, Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾):")); lay.addWidget(self.scope)
        lay.addWidget(QLabel("Ð ÐµÐ¶Ð¸Ð¼ Ð¿Ð¾Ð¸ÑÐºÐ°:")); lay.addWidget(self.mode)
        row = QHBoxLayout()
        okb = QPushButton("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ"); okb.clicked.connect(self.accept)
        cb = QPushButton("ÐžÑ‚Ð¼ÐµÐ½Ð°"); cb.clicked.connect(self.reject)
        row.addWidget(okb); row.addWidget(cb); lay.addLayout(row)
        if sf:
            self.name.setText(sf.get("name", ""))
            self.query.setText(sf.get("query", ""))
            self.scope.setText(sf.get("scope", ""))
            self.mode.setCurrentText("Ð‘Ð»Ð¾ÐºÐ¸" if sf.get("mode") == "Ð‘Ð»Ð¾ÐºÐ¸" else "ÐŸÐ¾Ð»Ñ")
    def value(self):
        return {
            "name": self.name.text().strip() or "Ð‘ÐµÐ· Ð¸Ð¼ÐµÐ½Ð¸",
            "query": self.query.text().strip(),
            "scope": self.scope.text().strip(),
            "mode": self.mode.currentText()
        }
class SmartFolderManager(QDialog):
    def __init__(self, smart_folders: list):
        super().__init__()
        self.setWindowTitle("Ð£Ð¼Ð½Ñ‹Ðµ Ð¿Ð°Ð¿ÐºÐ¸")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.sf = [dict(x) for x in smart_folders]
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels(["Ð˜Ð¼Ñ", "Ð—Ð°Ð¿Ñ€Ð¾Ñ", "Scope", "Ð ÐµÐ¶Ð¸Ð¼"])
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        thead = self.table.horizontalHeader()
        try:
            thead.setStretchLastSection(True)
        except Exception:
            pass
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        lay.addWidget(self.table)
        row = QHBoxLayout()
        addb = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ"); addb.clicked.connect(self.add)
        edb = QPushButton("Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ"); edb.clicked.connect(self.edit)
        delb = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"); delb.clicked.connect(self.delete)
        close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"); close.clicked.connect(self.accept)
        row.addWidget(addb); row.addWidget(edb); row.addWidget(delb); row.addStretch(1); row.addWidget(close)
        lay.addLayout(row)
        self.populate()
    def populate(self):
        self.table.setRowCount(0)
        for sf in self.sf:
            r = self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r, 0, QTableWidgetItem(sf.get("name", "")))
            self.table.setItem(r, 1, QTableWidgetItem(sf.get("query", "")))
            self.table.setItem(r, 2, QTableWidgetItem(sf.get("scope", "ALL")))
            self.table.setItem(r, 3, QTableWidgetItem(sf.get("mode", "ÐŸÐ¾Ð»Ñ")))
    def add(self):
        d = SmartFolderDialog()
        if d.exec() == QDialog.DialogCode.Accepted:
            self.sf.append(d.value()); self.populate()
    def edit(self):
        r = self.table.currentRow()
        if r < 0: return
        d = SmartFolderDialog(self.sf[r])
        if d.exec() == QDialog.DialogCode.Accepted:
            self.sf[r] = d.value(); self.populate()
    def delete(self):
        r = self.table.currentRow()
        if r < 0: return
        del self.sf[r]; self.populate()
    def value(self): return self.sf
class TemplatesManager(QDialog):
    def __init__(self, templates: list):
        super().__init__()
        self.setWindowTitle("Ð¨Ð°Ð±Ð»Ð¾Ð½Ñ‹ Ð±Ð»Ð¾ÐºÐ¾Ð²")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.tpl = [dict(x) for x in templates]
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Ð˜Ð¼Ñ ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°", "ÐŸÐ¾Ð»Ñ"])
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        thead = self.table.horizontalHeader()
        try:
            thead.setStretchLastSection(True)
        except Exception:
            pass
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        lay.addWidget(self.table)
        row = QHBoxLayout()
        addb = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ"); addb.clicked.connect(self.add)
        edb = QPushButton("Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ"); edb.clicked.connect(self.edit)
        delb = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"); delb.clicked.connect(self.delete)
        close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"); close.clicked.connect(self.accept)
        row.addWidget(addb); row.addWidget(edb); row.addWidget(delb); row.addStretch(1); row.addWidget(close)
        lay.addLayout(row)
        self.populate()
    def populate(self):
        self.table.setRowCount(0)
        for s in self.tpl:
            r = self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r, 0, QTableWidgetItem(s.get("name", "")))
            self.table.setItem(r, 1, QTableWidgetItem(", ".join(s.get("fields", []))))
    def add(self):
        name, ok = QInputDialog.getText(self, "Ð˜Ð¼Ñ ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ:")
        if not (ok and name): return
        fields, ok2 = QInputDialog.getText(self, "ÐŸÐ¾Ð»Ñ", "Ð§ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ:")
        if not ok2: return
        self.tpl.append({"name": name.strip(), "fields": [f.strip() for f in fields.split(",") if f.strip()]})
        self.populate()
    def edit(self):
        r = self.table.currentRow()
        if r < 0: return
        name, ok = QInputDialog.getText(self, "Ð˜Ð¼Ñ ÑˆÐ°Ð±Ð»Ð¾Ð½Ð°", "Ð˜Ð¼Ñ:", text=self.tpl[r].get("name", ""))
        if not (ok and name): return
        fields, ok2 = QInputDialog.getText(self, "ÐŸÐ¾Ð»Ñ", "Ð§ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ:", text=", ".join(self.tpl[r].get("fields", [])))
        if not ok2: return
        self.tpl[r] = {"name": name.strip(), "fields": [f.strip() for f in fields.split(",") if f.strip()]}
        self.populate()
    def delete(self):
        r = self.table.currentRow()
        if r < 0: return
        del self.tpl[r]; self.populate()
    def value(self): return self.tpl
class ExportPresetsManager(QDialog):
    def __init__(self, presets: list, all_fields: list):
        super().__init__()
        self.setWindowTitle("ÐŸÑ€ÐµÑÐµÑ‚Ñ‹ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.setModal(True)
        self.presets = [dict(x) for x in presets]
        self.all_fields = all_fields
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0, 2)
        self.table.setHorizontalHeaderLabels(["Ð˜Ð¼Ñ Ð¿Ñ€ÐµÑÐµÑ‚Ð°", "Ð¡Ñ‚Ð¾Ð»Ð±Ñ†Ñ‹"])
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        thead = self.table.horizontalHeader()
        try:
            thead.setStretchLastSection(True)
        except Exception:
            pass
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        lay.addWidget(self.table)
        row = QHBoxLayout()
        addb = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ"); addb.clicked.connect(self.add)
        edb = QPushButton("Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ"); edb.clicked.connect(self.edit)
        delb = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"); delb.clicked.connect(self.delete)
        close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"); close.clicked.connect(self.accept)
        row.addWidget(addb); row.addWidget(edb); row.addWidget(delb); row.addStretch(1); row.addWidget(close)
        lay.addLayout(row)
        self.populate()
    def populate(self):
        self.table.setRowCount(0)
        for s in self.presets:
            r = self.table.rowCount(); self.table.insertRow(r)
            self.table.setItem(r, 0, QTableWidgetItem(s.get("name", "")))
            self.table.setItem(r, 1, QTableWidgetItem(", ".join(s.get("columns", []))))
    def add(self):
        name, ok = QInputDialog.getText(self, "Ð˜Ð¼Ñ Ð¿Ñ€ÐµÑÐµÑ‚Ð°", "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ:")
        if not (ok and name): return
        cols, ok2 = QInputDialog.getText(self, "Ð¡Ñ‚Ð¾Ð»Ð±Ñ†Ñ‹", "Ð§ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ (Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð·Ð°Ñ€Ð°Ð½ÐµÐµ Ð¿Ð¾Ð»Ñ Ð² Ð±Ð»Ð¾ÐºÐ°Ñ…):")
        if not ok2: return
        self.presets.append({"name": name.strip(), "columns": [c.strip() for c in cols.split(",") if c.strip()]})
        self.populate()
    def edit(self):
        r = self.table.currentRow()
        if r < 0: return
        name, ok = QInputDialog.getText(self, "Ð˜Ð¼Ñ Ð¿Ñ€ÐµÑÐµÑ‚Ð°", "Ð˜Ð¼Ñ:", text=self.presets[r].get("name", ""))
        if not (ok and name): return
        cols, ok2 = QInputDialog.getText(self, "Ð¡Ñ‚Ð¾Ð»Ð±Ñ†Ñ‹", "Ð§ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ:", text=", ".join(self.presets[r].get("columns", [])))
        if not ok2: return
        self.presets[r] = {"name": name.strip(), "columns": [c.strip() for c in cols.split(",") if c.strip()]}
        self.populate()
    def delete(self):
        r = self.table.currentRow()
        if r < 0: return
        del self.presets[r]; self.populate()
    def value(self): return self.presets
class RecycleBinDialog(QDialog):
    def __init__(self, win: MainWindow):
        super().__init__(win)
        self.win = win
        self.setWindowTitle("ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(820, 520)
        lay = QVBoxLayout(self)
        trow = QHBoxLayout()
        self.filter = QLineEdit()
        self.filter.setPlaceholderText("Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ Ð¿Ð¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÑŽ/Ð¿ÑƒÑ‚Ð¸/IDâ€¦")
        self.filter.textChanged.connect(self.populate)
        trow.addWidget(self.filter)
        trow.addStretch(1)
        lay.addLayout(trow)
        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels(["ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ", "ÐžÑ‚ÐºÑƒÐ´Ð°", "ÐšÐ¾Ð³Ð´Ð°", "ID"])
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        thead = self.table.horizontalHeader()
        try:
            thead.setStretchLastSection(True)
        except Exception:
            pass
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        lay.addWidget(self.table)
        brow = QHBoxLayout()
        self.btn_restore = QPushButton("Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹")
        self.btn_restore.clicked.connect(self.restore_selected)
        self.btn_open = QPushButton("ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€)")
        self.btn_open.clicked.connect(self.open_selected)
        self.btn_clear_all = QPushButton("ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñƒ")
        self.btn_clear_all.clicked.connect(self.clear_all)
        btn_close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
        btn_close.clicked.connect(self.accept)
        t = self.win.theme
        r = int(t.get("btn_radius", 10))
        fg = t.get("btn_fg", "#FFF")
        self.btn_clear_all.setStyleSheet(
            f"background:{t['btn_delete_bg']};color:{fg};border:none;border-radius:{r}px;"
        )
        brow.addWidget(self.btn_restore)
        brow.addWidget(self.btn_open)
        brow.addStretch(1)
        brow.addWidget(self.btn_clear_all)
        brow.addWidget(btn_close)
        lay.addLayout(brow)
        self.table.itemDoubleClicked.connect(lambda *_: self.open_selected())
        self.table.itemSelectionChanged.connect(self._update_buttons)
        self._row_to_trash_index = []
        self.populate()
    def _update_buttons(self):
        has_sel = self.table.currentRow() >= 0
        self.btn_restore.setEnabled(has_sel)
        self.btn_open.setEnabled(has_sel)
        self.btn_clear_all.setEnabled(len(self.win.trash) > 0)
    def selected_index(self):
        r = self.table.currentRow()
        if 0 <= r < len(self._row_to_trash_index):
            return self._row_to_trash_index[r]
        return -1
    def populate(self):
        self.table.setRowCount(0)
        self._row_to_trash_index = []
        filt = (self.filter.text() or "").lower()
        for idx, t in enumerate(self.win.trash):
            b = t.get("block", {}) or {}
            title = b.get("title", "(Ð±ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ)")
            frm = t.get("from_key", "")
            ts = t.get("ts", "")
            bid = t.get("id", "")
            if filt:
                hay = " ".join([title, frm, ts, bid]).lower()
                if filt not in hay:
                    continue
            r = self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r, 0, QTableWidgetItem(title))
            self.table.setItem(r, 1, QTableWidgetItem(frm))
            self.table.setItem(r, 2, QTableWidgetItem(ts))
            self.table.setItem(r, 3, QTableWidgetItem(bid))
            self._row_to_trash_index.append(idx)
        if self.table.rowCount() > 0:
            self.table.scrollToBottom()
        self._update_buttons()
    def restore_selected(self):
        r = self.selected_index()
        if r < 0:
            custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐÐµ Ð²Ñ‹Ð±Ñ€Ð°Ð½ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚.")
            return
        it = self.win.trash[r]
        key = it.get("from_key", "")
        b = it.get("block")
        if not b:
            custom_warning(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð±Ð»Ð¾ÐºÐ°.")
            return
        if key:
            self.win._ensure_tree_path(key)
            self.win.save_tree()
            self.win.render_tree()
        self.win.blocks_data.setdefault(key, []).append(b)
        self.win.id_to_ref[b["id"]] = (key, b)
        self.win.update_index_for_block(b)
        del self.win.trash[r]
        self.win.save_blocks()
        self.win.save_trash()
        self.populate()
        self.win.current_path = [p for p in key.split("/") if p]
        self.win.schedule_render()
        audit_write("trash_restore", {"block_id": b["id"], "to": key})
        custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾.")
    def open_selected(self):
        r = self.selected_index()
        if r < 0:
            custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐÐµ Ð²Ñ‹Ð±Ñ€Ð°Ð½ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚.")
            return
        it = self.win.trash[r]
        b = it.get("block")
        if not b:
            custom_warning(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð±Ð»Ð¾ÐºÐ°.")
            return
        BlockEditorDialog(self.win, b).exec()
    def clear_all(self):
        if not self.win.trash:
            custom_info(self, "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°", "ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð° ÑƒÐ¶Ðµ Ð¿ÑƒÑÑ‚Ð°.")
            return
        self.win.clear_trash()
        self.populate()
class ExportTasksManager(QDialog):
    def __init__(self, win: MainWindow):
        super().__init__(win)
        self.win = win
        self.setWindowTitle("Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð¿Ð¾ Ñ€Ð°ÑÐ¿Ð¸ÑÐ°Ð½Ð¸ÑŽ")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(900, 520)
        self.tasks = [dict(x) for x in (self.win.meta.get("export_tasks") or [])]
        self._migrate_tasks_inplace()
        lay = QVBoxLayout(self)
        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels([
            "Ð˜Ð¼Ñ", "Ð¢Ð¸Ð¿", "ÐšÐ°Ð¶Ð´Ñ‹Ðµ (Ð¼Ð¸Ð½)", "Ð’Ñ€ÐµÐ¼Ñ (ÐµÐ¶ÐµÐ´Ð½.)", "ÐŸÐ°Ð¿ÐºÐ°", "Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹ Ð·Ð°Ð¿ÑƒÑÐº"
        ])
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        thead = self.table.horizontalHeader()
        try:
            thead.setStretchLastSection(True)
        except Exception:
            pass
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        lay.addWidget(self.table)
        row = QHBoxLayout()
        b_add = QPushButton("Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ"); b_add.clicked.connect(self.add)
        b_edit = QPushButton("Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ"); b_edit.clicked.connect(self.edit)
        b_del = QPushButton("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"); b_del.clicked.connect(self.delete)
        b_run = QPushButton("Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ ÑÐµÐ¹Ñ‡Ð°Ñ"); b_run.clicked.connect(self.run_now)
        b_path = QPushButton("ÐŸÐ°Ð¿ÐºÐ° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°â€¦"); b_path.clicked.connect(self.pick_folder_for_selected)
        b_close = QPushButton("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ"); b_close.clicked.connect(self.accept)
        row.addWidget(b_add); row.addWidget(b_edit); row.addWidget(b_del); row.addWidget(b_run); row.addWidget(b_path)
        row.addStretch(1); row.addWidget(b_close)
        lay.addLayout(row)
        self.populate()
    def _migrate_tasks_inplace(self):
        changed = False
        for t in self.tasks:
            if not t.get("path_dir"):
                legacy_path = (t.get("path") or "").strip()
                if legacy_path:
                    pd = os.path.dirname(legacy_path)
                    if pd:
                        t["path_dir"] = pd
                        changed = True
            t.setdefault("name", "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚")
            t.setdefault("type", "interval")
            t.setdefault("every_min", 60)
            t.setdefault("at_time", "02:00")
            t.setdefault("seq", 1)
            t.setdefault("enc_pwd_enc", t.get("enc_pwd_enc", ""))
            if not t.get("next_run"):
                t["next_run"] = self.win.calc_next_run(
                    t.get("type", "interval"),
                    int(t.get("every_min", 60)),
                    t.get("at_time", "02:00")
                )
                changed = True
        if changed:
            self.win.meta["export_tasks"] = self.tasks
            self.win.save_meta()
    def populate(self):
        self.table.setRowCount(0)
        for t in self.tasks:
            r = self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r, 0, QTableWidgetItem(t.get("name", "")))
            self.table.setItem(r, 1, QTableWidgetItem(t.get("type", "interval")))
            self.table.setItem(r, 2, QTableWidgetItem(str(t.get("every_min", ""))))
            self.table.setItem(r, 3, QTableWidgetItem(t.get("at_time", "")))
            self.table.setItem(r, 4, QTableWidgetItem(t.get("path_dir", "")))
            self.table.setItem(r, 5, QTableWidgetItem(t.get("next_run", "")))
    def selected(self):
        r = self.table.currentRow()
        return (r, self.tasks[r]) if 0 <= r < len(self.tasks) else (-1, None)
    def add(self):
        d = ExportTaskEditDialog(self.win, None)
        if d.exec() == QDialog.DialogCode.Accepted:
            self.tasks.append(d.value())
            self.save()
    def edit(self):
        i, t = self.selected()
        if t is None:
            return
        d = ExportTaskEditDialog(self.win, t)
        if d.exec() == QDialog.DialogCode.Accepted:
            self.tasks[i] = d.value()
            self.save()
    def delete(self):
        i, t = self.selected()
        if t is None:
            return
        del self.tasks[i]
        self.save()
    def run_now(self):
        _, t = self.selected()
        if t is None:
            return
        self.win.run_export_task(t)
        custom_info(self, "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚", "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð¿Ð°Ð¿ÐºÑƒ Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ.")
    def pick_folder_for_selected(self):
        i, t = self.selected()
        if t is None:
            return
        start = t.get("path_dir", "") or DATA_DIR
        path = QFileDialog.getExistingDirectory(self, "ÐŸÐ°Ð¿ÐºÐ° Ð´Ð»Ñ Ð±ÑÐºÐ°Ð¿Ð¾Ð²", start)
        if not path:
            return
        t["path_dir"] = path
        self.save()
    def save(self):
        self.win.meta["export_tasks"] = self.tasks
        self.win.save_meta()
        self.populate()        
class QRDialog(QDialog):
    def __init__(self, title: str, payload_text: str, parent=None):
        super().__init__(parent)
        self.setWindowTitle("QR: " + (title or ""))
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(420, 480)
        lay = QVBoxLayout(self)
        self.lbl = QLabel("QR Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½: ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ Ð¿Ð°ÐºÐµÑ‚ 'qrcode'.")
        self.lbl.setAlignment(Qt.AlignmentFlag.AlignCenter)
        lay.addWidget(self.lbl)
        row = QHBoxLayout()
        b_copy = QPushButton("Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚")
        def _copy_now():
            QApplication.clipboard().setText(payload_text)
            try:
                parent = self.parent()
                if hasattr(parent, "clip_timer") and hasattr(parent, "CLIPBOARD_SEC"):
                    parent.clip_timer.start(parent.CLIPBOARD_SEC * 1000)
            except Exception:
                pass
        b_copy.clicked.connect(_copy_now)
        b_save = QPushButton("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ PNGâ€¦")
        b_save.clicked.connect(self.save_png)
        row.addWidget(b_copy)
        row.addStretch(1)
        row.addWidget(b_save)
        lay.addLayout(row)
        self._png_bytes = None
        try:
            import qrcode
            qr = qrcode.QRCode(border=2)
            qr.add_data(payload_text)
            img = qr.make_image()
            buf = io.BytesIO()
            img.save(buf, "PNG")
            self._png_bytes = buf.getvalue()
            pm = QPixmap()
            pm.loadFromData(self._png_bytes)
            self.lbl.setPixmap(
                pm.scaled(360, 360,
                          Qt.AspectRatioMode.KeepAspectRatio,
                          Qt.TransformationMode.SmoothTransformation)
            )
            self.lbl.setText("")
        except Exception:
            pass
    def save_png(self):
        if not self._png_bytes:
            custom_warning(self, "QR", "ÐœÐ¾Ð´ÑƒÐ»ÑŒ 'qrcode' Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ QR", "qr.png", "PNG (*.png)")
        if not path:
            return
        with open(path, "wb") as f:
            f.write(self._png_bytes)
        custom_info(self, "QR", "Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾.")
class ExportTaskEditDialog(QDialog):
    def __init__(self, win: MainWindow, task: dict | None):
        super().__init__(win)
        self.win = win
        self.setWindowTitle("Ð—Ð°Ð´Ð°Ñ‡Ð° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°")
        if os.path.exists(ICON_PATH):
            self.setWindowIcon(QIcon(ICON_PATH))
        self.resize(560, 360)
        self._task = dict(task) if task else {
            "name": "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚",
            "type": "interval",
            "every_min": 60,
            "at_time": "02:00",
            "path_dir": "",
            "enc_pwd_enc": "",
            "seq": 1,
            "next_run": "",
        }
        lay = QVBoxLayout(self)
        self.e_name = QLineEdit(self._task.get("name", "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚"))
        self.c_type = QComboBox(); self.c_type.addItems(["interval", "daily"])
        self.c_type.setCurrentText(self._task.get("type", "interval"))
        self.e_every = QSpinBox(); self.e_every.setRange(1, 100000)
        try:
            self.e_every.setValue(int(self._task.get("every_min", 60)))
        except Exception:
            self.e_every.setValue(60)
        self.e_time = QLineEdit(self._task.get("at_time", "02:00"))
        self.e_path = QLineEdit(self._task.get("path_dir", ""))
        b_browse = QPushButton("â€¦"); b_browse.clicked.connect(self.pick_folder)
        self.e_pwd = QLineEdit(); self.e_pwd.setEchoMode(QLineEdit.EchoMode.Password)
        try:
            cur_pwd = decrypt_value(self._task.get("enc_pwd_enc",""), self.win.fernet) if self._task.get("enc_pwd_enc") else ""
            if cur_pwd: self.e_pwd.setText(cur_pwd)
        except Exception:
            pass
        form = QGridLayout()
        rowi = 0
        form.addWidget(QLabel("Ð˜Ð¼Ñ:"), rowi, 0); form.addWidget(self.e_name, rowi, 1, 1, 2); rowi += 1
        form.addWidget(QLabel("Ð¢Ð¸Ð¿:"), rowi, 0); form.addWidget(self.c_type, rowi, 1); rowi += 1
        form.addWidget(QLabel("ÐšÐ°Ð¶Ð´Ñ‹Ðµ (Ð¼Ð¸Ð½):"), rowi, 0); form.addWidget(self.e_every, rowi, 1); rowi += 1
        form.addWidget(QLabel("Ð’Ñ€ÐµÐ¼Ñ (ÐµÐ¶ÐµÐ´Ð½ÐµÐ²Ð½Ð¾):"), rowi, 0); form.addWidget(self.e_time, rowi, 1); rowi += 1
        form.addWidget(QLabel("ÐŸÐ°Ð¿ÐºÐ° Ð´Ð»Ñ Ð±ÑÐºÐ°Ð¿Ð¾Ð²:"), rowi, 0); form.addWidget(self.e_path, rowi, 1); form.addWidget(b_browse, rowi, 2); rowi += 1
        form.addWidget(QLabel("ÐŸÐ°Ñ€Ð¾Ð»ÑŒ (LPX1):"), rowi, 0); form.addWidget(self.e_pwd, rowi, 1, 1, 2); rowi += 1
        lay.addLayout(form)
        btns = QHBoxLayout()
        ok = QPushButton("Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ"); ok.clicked.connect(self.accept)
        cancel = QPushButton("ÐžÑ‚Ð¼ÐµÐ½Ð°"); cancel.clicked.connect(self.reject)
        btns.addStretch(1); btns.addWidget(ok); btns.addWidget(cancel)
        lay.addLayout(btns)
        self.c_type.currentTextChanged.connect(self._toggle_rows)
        self._toggle_rows(self.c_type.currentText())
    def _toggle_rows(self, typ: str):
        self.e_every.setEnabled(typ == "interval")
        self.e_time.setEnabled(typ == "daily")
    def pick_folder(self):
        start = self.e_path.text().strip() or DATA_DIR
        path = QFileDialog.getExistingDirectory(self, "ÐŸÐ°Ð¿ÐºÐ° Ð´Ð»Ñ Ð±ÑÐºÐ°Ð¿Ð¾Ð²", start)
        if path:
            self.e_path.setText(path)
    def value(self):
        ttype = self.c_type.currentText() or "interval"
        every = int(self.e_every.value())
        at    = self.e_time.text().strip() or "02:00"
        pwd   = self.e_pwd.text().strip()
        t = {
            "name": self.e_name.text().strip() or "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚",
            "type": ttype,
            "every_min": every,
            "at_time": at,
            "path_dir": self.e_path.text().strip(),
            "enc_pwd_enc": encrypt_value(pwd, self.win.fernet) if pwd else self._task.get("enc_pwd_enc", ""),
            "seq": int(self._task.get("seq", 1)),
            "next_run": self.win.calc_next_run(ttype, every, at),
        }
        return t
def install_russian_translator(app: QApplication):
    try:
        QLocale.setDefault(QLocale(QLocale.Language.Russian, QLocale.Country.Russia))
    except Exception:
        pass
    try:
        from PySide6.QtCore import QTranslator, QLibraryInfo
        tr = QTranslator(app)
        try:
            path = QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath)
        except Exception:
            path = os.path.join(sys.prefix, "Lib", "site-packages", "PySide6", "Qt6", "translations")
        if tr.load("qtbase_ru", path):
            app.installTranslator(tr)
    except Exception:
        pass
def ask_master_password() -> str | None:
    first_run = not os.path.exists(MASTER_FILE)
    dlg = MasterPasswordDialog(None, first_run=first_run)
    return dlg.value() if dlg.exec() == QDialog.DialogCode.Accepted else None
def _vault_exists() -> bool:
    try:
        if any(os.path.exists(p) for p in (TREE_FILE, BLOCKS_FILE, META_FILE, TRASH_FILE, INDEX_DB)):
            return True
        if os.path.isdir(ATTACH_DIR):
            with os.scandir(ATTACH_DIR) as it:
                for _ in it:
                    return True
    except Exception:
        pass
    return False
def main():
    print("[LinkPass] starting...")
    app = QApplication(sys.argv)
    install_russian_translator(app)
    app.setQuitOnLastWindowClosed(True)
    first_run = not os.path.exists(MASTER_FILE)
    if first_run:
        dlg = MasterPasswordDialog(None, first_run=True)
        if dlg.exec() != QDialog.DialogCode.Accepted:
            return 0
        master = dlg.value()
        try:
            win = MainWindow(master)
        except Exception as e:
            try:
                custom_error(None, "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ°", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ:\n{e}")
            except Exception:
                pass
            return 1
    else:
        win = None
        while True:
            dlg = MasterPasswordDialog(None, first_run=False)
            if dlg.exec() != QDialog.DialogCode.Accepted:
                return 0
            master = dlg.value()
            try:
                with open(MASTER_FILE, "r", encoding="utf-8") as f:
                    j = json.load(f)
                auth_salt = base64.b64decode(j.get("auth_salt", "") or b"")
                kdf_name  = j.get("kdf", "argon2id")
                kdf_params = j.get("kdf_params") or KDF_DEFAULTS
                calc = hash_for_auth(master, auth_salt, prefer_argon=(kdf_name == "argon2id"), params=kdf_params)
                if calc != j.get("verifier"):
                    custom_error(None, "ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·.")
                    continue
            except Exception:
                pass

            try:
                win = MainWindow(master)
                break
            except WrongMasterPasswordError:
                try:
                    custom_error(None, "ÐœÐ°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ", "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¼Ð°ÑÑ‚ÐµÑ€â€‘Ð¿Ð°Ñ€Ð¾Ð»ÑŒ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·.")
                except Exception:
                    pass
                continue
            except Exception as e:
                try:
                    custom_error(None, "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ°", f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ:\n{e}")
                except Exception:
                    pass
                return 1
    win.show()
    try:
        win.raise_()
        win.activateWindow()
    except Exception:
        pass
    print("[LinkPass] UI shown; entering event loop")
    rc = app.exec()
    print("[LinkPass] exited", rc)
    return rc
if __name__ == "__main__":
    sys.exit(main())
